<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>java基础 | Asahi</title><meta name="author" content="Asahi"><meta name="copyright" content="Asahi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Java Foundationjava编译原理 xx.java文件经过javac命令编译成xx.class字节码文件    xx.class字节码文件再在不同操作系统的JVM中运行  JDK、JRE JDK &#x3D; JRE + 开发工具集 JRE &#x3D; JVM + java SE 标准类库（java核心类库）  配置环境变量 java开发注意事项 一个源文件中最多只能有一个publi">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础">
<meta property="og:url" content="https://asahif.github.io/2023/03/26/java/index.html">
<meta property="og:site_name" content="Asahi">
<meta property="og:description" content="Java Foundationjava编译原理 xx.java文件经过javac命令编译成xx.class字节码文件    xx.class字节码文件再在不同操作系统的JVM中运行  JDK、JRE JDK &#x3D; JRE + 开发工具集 JRE &#x3D; JVM + java SE 标准类库（java核心类库）  配置环境变量 java开发注意事项 一个源文件中最多只能有一个publi">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://service-5z0sdahv-1306777571.sh.apigw.tencentcs.com/release/">
<meta property="article:published_time" content="2023-03-26T11:26:58.210Z">
<meta property="article:modified_time" content="2023-03-20T03:25:00.000Z">
<meta property="article:author" content="Asahi">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://service-5z0sdahv-1306777571.sh.apigw.tencentcs.com/release/"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://asahif.github.io/2023/03/26/java/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/NSimSun" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-03-20 11:25:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/card.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></div><div class="menus_item"><a class="site-page" href="/comments/index.html"><i class="fa-fw fas fa-link"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent"><nav id="nav"><span id="blog-info"><a href="/" title="Asahi"><span class="site-name">Asahi</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></div><div class="menus_item"><a class="site-page" href="/comments/index.html"><i class="fa-fw fas fa-link"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-26T11:26:58.210Z" title="发表于 2023-03-26 19:26:58">2023-03-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-20T03:25:00.000Z" title="更新于 2023-03-20 11:25:00">2023-03-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">27k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>102分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Java-Foundation"><a href="#Java-Foundation" class="headerlink" title="Java Foundation"></a>Java Foundation</h1><h4 id="java编译原理"><a href="#java编译原理" class="headerlink" title="java编译原理"></a>java编译原理</h4><ol>
<li>xx.java文件经过javac命令编译成xx.class字节码文件   </li>
<li>xx.class字节码文件再在不同操作系统的<strong>JVM</strong>中运行</li>
</ol>
<h4 id="JDK、JRE"><a href="#JDK、JRE" class="headerlink" title="JDK、JRE"></a>JDK、JRE</h4><ul>
<li><strong>JDK</strong> &#x3D; <strong>JRE</strong> + 开发工具集</li>
<li><strong>JRE</strong> &#x3D; <strong>JVM</strong> + java SE 标准类库（java核心类库）</li>
</ul>
<h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220307212603791.png" alt="image-20220307212603791"></p>
<h4 id="java开发注意事项"><a href="#java开发注意事项" class="headerlink" title="java开发注意事项"></a>java开发注意事项</h4><ul>
<li>一个源文件中最多只能有一个<strong>public类</strong>，其他类的个数不限</li>
<li>如果源文件中包含一个public类，则文件名必须按该类名命名</li>
<li>可以将main方法写在非public类中，然后指定运行非public类</li>
</ul>
<h4 id="java代码-x2F-命名规范"><a href="#java代码-x2F-命名规范" class="headerlink" title="java代码&#x2F;命名规范"></a>java代码&#x2F;命名规范</h4><ul>
<li>类、方法的注释，要以<strong>javadoc</strong>的方式来写</li>
<li>源文件使用<strong>utf-8</strong>编码</li>
<li>代码编写用次行风格或行尾风格</li>
<li><strong>包名</strong>所有字母都小写</li>
<li><strong>类名</strong>或<strong>接口名</strong>每个单词首字母要大写</li>
<li><strong>变量名</strong>或<strong>方法名</strong>使用<strong>驼峰法</strong>命名</li>
<li><strong>常量</strong>的每个字母需要大写</li>
</ul>
<h4 id="JVM的内存组成"><a href="#JVM的内存组成" class="headerlink" title="JVM的内存组成"></a>JVM的内存组成</h4><ul>
<li>由<strong>栈（stack）</strong>、<strong>堆（heap）</strong>、<strong>方法区</strong>组成</li>
<li>方法区内含<strong>常量池</strong>，String类型储存在常量池当中</li>
</ul>
<hr>
<h4 id="String类型与基本数据类型的转化"><a href="#String类型与基本数据类型的转化" class="headerlink" title="String类型与基本数据类型的转化"></a>String类型与基本数据类型的转化</h4><ul>
<li>String-&gt;basic</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(str1);</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;true&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">pass</span> <span class="operator">=</span> Boolean.parseBoolean(str2);</span><br></pre></td></tr></table></figure>

<ul>
<li>basic-&gt;String</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="number">123</span> + <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220307091409145.png" alt="image-20220307091409145"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220307091344569.png" alt="image-20220307091344569"></p>
<h4 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220307091632644.png" alt="image-20220307091632644"></p>
<h4 id="进制表示"><a href="#进制表示" class="headerlink" title="进制表示"></a>进制表示</h4><ul>
<li>二进制：0b或0B开头</li>
<li>八进制：0开头</li>
<li>十六进制：0x或0X开头</li>
</ul>
<h4 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220307091822376.png" alt="image-20220307091822376"></p>
<h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220307092027772.png" alt="image-20220307092027772"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220307092047410.png" alt="image-20220307092047410"></p>
<hr>
<h4 id="循环（loop）"><a href="#循环（loop）" class="headerlink" title="循环（loop）"></a>循环（loop）</h4><ul>
<li>for循环</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220307092220651.png" alt="image-20220307092220651"></p>
<ul>
<li>while循环</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220307092322357.png" alt="image-20220307092322357"></p>
<ul>
<li>do-while循环</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220307092445721.png" alt="image-20220307092445721"></p>
<h4 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a>增强for</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//普通的 for 循环</span></span><br><span class="line">System.out.println(<span class="string">&quot;=====普通的 for=====&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">	System.out.println(nums[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;=====增强的 for=====&quot;</span>);</span><br><span class="line"><span class="comment">//执行流程是 依次从 nums 数组中取出数据，赋给 i, 如果取出完毕，则退出 for</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i : nums) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;i=&quot;</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li>数组长度一旦确定就无法修改</li>
<li>数组扩容需新建一个数组将元素copy后在添加元素，然后重新指向新数组，原数组会被销毁</li>
</ul>
<h4 id="赋值（值拷贝-x2F-地址拷贝）"><a href="#赋值（值拷贝-x2F-地址拷贝）" class="headerlink" title="赋值（值拷贝&#x2F;地址拷贝）"></a>赋值（值拷贝&#x2F;地址拷贝）</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220307092627910.png" alt="image-20220307092627910"></p>
<h3 id="类（public）于对象（object）"><a href="#类（public）于对象（object）" class="headerlink" title="类（public）于对象（object）"></a>类（public）于对象（object）</h3><ul>
<li>一个类包含<strong>属性</strong>、<strong>成员方法</strong>、<strong>构造器</strong></li>
<li>类是抽象的，概念的，代表一类事物，即<strong>数据类型</strong>（datatype）</li>
<li>对象是具体的，实际的，代表一个具体的事物，即<strong>实例</strong>（instance）</li>
<li>类是对象的模板，对象是类的一个个体，对应一个实例</li>
</ul>
<h4 id="对象在内存中的存在形式"><a href="#对象在内存中的存在形式" class="headerlink" title="对象在内存中的存在形式"></a>对象在内存中的存在形式</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220308151112727.png" alt="image-20220308151112727"></p>
<h4 id="属性-x2F-成员变量-x2F-字段（field）"><a href="#属性-x2F-成员变量-x2F-字段（field）" class="headerlink" title="属性&#x2F;成员变量&#x2F;字段（field）"></a>属性&#x2F;成员变量&#x2F;字段（field）</h4><ul>
<li>属性不赋值会有默认值: int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \u0000， boolean false，String null</li>
<li>全局变量&#x2F;属性可以加修饰符</li>
</ul>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><ul>
<li>属性之外的变量，作用域为定义其的代码块中</li>
<li>局部变量没有初始值，只有赋值后才能使用</li>
<li><strong>局部变量不可加修饰符</strong></li>
</ul>
<h4 id="构造器-x2F-构造方法"><a href="#构造器-x2F-构造方法" class="headerlink" title="构造器&#x2F;构造方法"></a>构造器&#x2F;构造方法</h4><ul>
<li><p>方法名和类名相同</p>
</li>
<li><p>没有返回值</p>
</li>
<li><p>在创建对象时，系统会自动的调用该类的构造器<strong>完成对象的初始化</strong></p>
</li>
<li><p>没有定义构造器时系统会定义一个默认的无参构造器，如Dog(){}</p>
</li>
<li><p>一旦自己定义构造器，默认构造器会被覆盖，若需继续使用，需要显式定义</p>
</li>
</ul>
<h4 id="对象创建的流程"><a href="#对象创建的流程" class="headerlink" title="对象创建的流程"></a>对象创建的流程</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220308145710599.png" alt="image-20220308145710599"></p>
<ul>
<li>流程分析</li>
</ul>
<ol>
<li>加载Person类信息（person.class），只加载一次</li>
<li>在堆（heap）中分配空间（地址）</li>
<li>完成对象初始化<ol>
<li>默认初始化：age &#x3D; 0,name &#x3D; null</li>
<li>显式初始化：age &#x3D; 90，name &#x3D; null</li>
<li>构造器初始化：age &#x3D; 20，name &#x3D; n</li>
</ol>
</li>
<li>将对象在堆中的地址，返回给p（p可以是对象名，也可以理解成是对象的引用）</li>
</ol>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>... nums)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">	res += nums[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可变参数当作数组使用，本质就是数组</li>
<li>必须放在形参列表的最后一个位置</li>
</ul>
<h4 id="随机数-x2F-字符生成"><a href="#随机数-x2F-字符生成" class="headerlink" title="随机数&#x2F;字符生成"></a>随机数&#x2F;字符生成</h4><ul>
<li>使用Math.random()方法</li>
<li>该方法生成0~9之间的随机数</li>
<li>生成<strong>a ~ a + b之间的随机数</strong>：<strong>a + Math.random() * (b - a)</strong></li>
<li>生成**’A’ ~ ‘Z’<strong>之间随机数：</strong>(char)(‘a’ + random() * (‘Z’ - ‘A’ - 1))**</li>
</ul>
<h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><ul>
<li>本质式创建不同的文件夹来保存类文件</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220308151716759.png" alt="image-20220308151716759"></p>
<ul>
<li>基本语法：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220308152005048.png" alt="image-20220308152005048"></li>
</ul>
<h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><ul>
<li><strong>public</strong>、<strong>protected</strong>、<strong>默认</strong>、<strong>private</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220308152304364.png" alt="image-20220308152304364"></p>
<hr>
<h2 id="面向对象的三大特征：封装、继承、多态"><a href="#面向对象的三大特征：封装、继承、多态" class="headerlink" title="面向对象的三大特征：封装、继承、多态"></a>面向对象的三大特征：封装、继承、多态</h2><h3 id="封装（encapsulation）"><a href="#封装（encapsulation）" class="headerlink" title="封装（encapsulation）"></a>封装（encapsulation）</h3><ul>
<li>把抽象出的数据【属性】和对应数据的操作【方法】封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作【方法】，才能堆数据进行操作</li>
<li>隐藏实现细节：方法（连接数据库）&lt;–调用（传入参数..）</li>
<li>可以对数据进行验证，保证安全合理</li>
</ul>
<h4 id="封装实现的步骤"><a href="#封装实现的步骤" class="headerlink" title="封装实现的步骤"></a>封装实现的步骤</h4><ol>
<li>将属性进行私有化private【不能直接修改】</li>
<li>提供一个公共的（public）set方法，用于对属性判断并赋值</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setXXX</span><span class="params">(类型 参数名)</span>&#123;</span><br><span class="line">    <span class="comment">//加入数据验证的业务逻辑</span></span><br><span class="line">    属性 = 参数名;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>提供一个公共的（public）get方法，用于获取属性的值</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> 数据类型 getXXX()&#123;</span><br><span class="line">	<span class="comment">//权限判断</span></span><br><span class="line">	<span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="封装与构造器"><a href="#封装与构造器" class="headerlink" title="封装与构造器"></a>封装与构造器</h4><ul>
<li>防护机制可以通过构造器破解</li>
<li>故可以将setXXX()方法嵌套进构造器中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">    setAge(age);</span><br><span class="line">    setName(name);</span><br><span class="line">    setSalary(salary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="继承（extend）"><a href="#继承（extend）" class="headerlink" title="继承（extend）"></a>继承（extend）</h3><ul>
<li>可以解决代码复用</li>
<li>子类必须调用父类构造器，后调用子类自身的构造器</li>
<li><strong>每个构造器都默认有个super()</strong>;</li>
<li>子类默认调用父类的无参构造器，如果父类没有提供无参构造器，则必须<strong>在子类的构造器中用super</strong>去指定使用父类的哪个构造器完成对父类的初始化工作，否则编译不通过</li>
<li>super()和this()都只能放在构造器的第一行，故两者只能同时使用一个,<strong>调用了this()时，默认的super()会被挤掉</strong></li>
<li>java所有类都是<strong>Object</strong>的子类</li>
<li>java单继承机制，一个子类只能继承一个父类</li>
<li>父类的属性由父类的构造器初始化，子类的构造器完成子类的初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.extend_;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 讲解继承的本质</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsTheory</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();<span class="comment">//内存的布局</span></span><br><span class="line">	System.out.println(son.name);<span class="comment">//返回就是大头儿子</span></span><br><span class="line">	<span class="comment">//System.out.println(son.age);//返回的就是 39</span></span><br><span class="line">	<span class="comment">//System.out.println(son.getAge());//返回的就是 39</span></span><br><span class="line">	System.out.println(son.hobby);<span class="comment">//返回的就是旅游</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandPa</span> &#123; <span class="comment">//爷类</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;大头爷爷</span></span><br><span class="line"><span class="string">	String hobby = &quot;</span>旅游<span class="string">&quot;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">class Father extends GrandPa &#123;//父类</span></span><br><span class="line"><span class="string">	String name = &quot;</span>大头爸爸<span class="string">&quot;;</span></span><br><span class="line"><span class="string">	private int age = 39;</span></span><br><span class="line"><span class="string">	public int getAge() &#123;</span></span><br><span class="line"><span class="string">		return age;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">class Son extends Father &#123; //子类</span></span><br><span class="line"><span class="string">	String name = &quot;</span>大头儿子<span class="string">&quot;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>这时请大家注意，要按照查找关系来返回信息</p>
<ol>
<li>首先看子类是否有该属性</li>
<li>如果子类有这个属性，并且可以访问，则返回信息</li>
<li>如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息..)</li>
<li>如果父类没有就按照(3)的规则，继续找上级父类，直到 Object… </li>
<li>如果其中有属性被private保护而<strong>不能被访问</strong>，<strong>不会继续往上一级访问</strong>，被卡就报错</li>
</ol>
</li>
</ul>
<h4 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h4><ul>
<li>代表父类应用，用于访问父类的属性，方法，构造器</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220310182147771.png" alt="image-20220310182147771"></p>
<ul>
<li>super 的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用 super 去访问爷爷类的成员；</li>
<li>如果多个基类(上级类)中都有同名的成员，使用 super 访问遵循就近原则。</li>
</ul>
<table>
<thead>
<tr>
<th>NO.</th>
<th>区别点</th>
<th>this</th>
<th>super</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>访问属性</td>
<td>访问<strong>本类</strong>中的属性，若本类<strong>没有</strong>此属性则<strong>从父类中继续查找</strong></td>
<td>从<strong>父类开始</strong>查找属性</td>
</tr>
<tr>
<td>2</td>
<td>调用方法</td>
<td>访问<strong>本类</strong>中的方法，若本类<strong>没有</strong>此方法则<strong>从父类中继续查找</strong></td>
<td>从<strong>父类开始</strong>查找方法</td>
</tr>
<tr>
<td>3</td>
<td>调用构造器</td>
<td>调用<strong>本类构造器</strong>，必须<strong>位于构造器的首行</strong></td>
<td>调用<strong>父类构造器</strong>，必须<strong>放在子类构造器的首行</strong></td>
</tr>
<tr>
<td>4</td>
<td>特殊</td>
<td>表示<strong>当前对象</strong></td>
<td>子类中<strong>访问父类对象</strong></td>
</tr>
</tbody></table>
<h4 id="方法重写-x2F-覆盖（override）"><a href="#方法重写-x2F-覆盖（override）" class="headerlink" title="方法重写&#x2F;覆盖（override）"></a>方法重写&#x2F;覆盖（override）</h4><ul>
<li>override就是子类有一个方法，和父类的某个方法的<strong>名称</strong>、<strong>返回类型</strong>、<strong>形参列表</strong>一样，那么就说此方法<strong>覆盖</strong>了父类的方法</li>
<li>子类方法的返回类型<strong>和父类方法的返回类型一致</strong>，或是父类的<strong>子类</strong></li>
<li>子类方法<strong>不能缩小父类方法的访问权限</strong></li>
</ul>
<table>
<thead>
<tr>
<th>名城</th>
<th>发生范围</th>
<th>方法名</th>
<th>形参列表</th>
<th>返回类型</th>
<th>修饰符</th>
</tr>
</thead>
<tbody><tr>
<td>重载（overload）</td>
<td>本类</td>
<td>必须一样</td>
<td><strong>类型</strong>，<strong>个数</strong>，<strong>排序</strong>至少有一个不同</td>
<td>无要求</td>
<td>无要求</td>
</tr>
<tr>
<td>重写（override）</td>
<td>父子类</td>
<td>必须一样</td>
<td>相同</td>
<td>子类重写 的方法，返回类型和父类<strong>返回的类型一致</strong>，或者是其<strong>子类</strong></td>
<td>子类方法不能缩小父类的访问范围</td>
</tr>
</tbody></table>
<h4 id="子类创建的内存布局"><a href="#子类创建的内存布局" class="headerlink" title="子类创建的内存布局"></a>子类创建的内存布局</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220309215815557.png" alt="image-20220309215815557"></p>
<h3 id="多态（Polymorphism）"><a href="#多态（Polymorphism）" class="headerlink" title="多态（Polymorphism）"></a>多态（Polymorphism）</h3><ul>
<li><p>方法多态</p>
<ul>
<li>方法的<strong>重写</strong>体现多态</li>
<li>方法的<strong>重载</strong>体现多态</li>
</ul>
</li>
<li><p>对象多态</p>
<ul>
<li>对象的<strong>编译类型</strong>和<strong>运行类型</strong>可以不一致</li>
<li>对象的<strong>编译类型在编译时确定，不能变化</strong></li>
<li>对象的<strong>运行类型是可以变化的</strong>，可以通过**gerClass()**方法查看运行类型</li>
<li><strong>编译类型看等号&#x3D;左边</strong>，<strong>运行类型看&#x3D;右边</strong></li>
</ul>
</li>
<li><p>接口存在多态传递现象</p>
<ul>
<li>接口类型的变量xx可以指向实现了XX接口类的对象实例（参考对象的编译类型和运行类型规则）</li>
<li><strong>多态传递现象</strong>：如果IG继承了IH接口，而Teacher类实现了IG接口，那么实际上相当于Teacher类也实现了IG接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IH <span class="keyword">extends</span> <span class="title class_">IG</span>&#123;&#125;</span><br><span class="line">Teacher <span class="keyword">implements</span> <span class="title class_">IH</span>&#123;&#125;</span><br><span class="line">----&gt;</span><br><span class="line">Teacher <span class="keyword">implements</span> <span class="title class_">IH</span>,IG&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h5><ul>
<li>本质：父类的引用指向了之类的对象</li>
<li>语法：<strong>父类类型 引用名 &#x3D; new 子类类型()</strong></li>
<li>特点：<strong>编译类型</strong>看左边，<strong>运行类型</strong>看右边。<ul>
<li>可以调用父类中的<strong>所有成员</strong>（须遵守访问权限）</li>
<li>不能调用子类中的<strong>特有成员</strong></li>
<li>最终运行效果看子类的具体实现</li>
</ul>
</li>
</ul>
<h5 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h5><ul>
<li>语法：<strong>子类类型 引用名 &#x3D; （子类类型）父类引用</strong></li>
<li>只能强转父类的<strong>引用</strong>，不能强转父类的<strong>对象</strong>、</li>
<li>要求父类的引用必须指向的是<strong>当前的目标类型</strong>（需要强转的对象类型）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();<span class="comment">//向上转型</span></span><br><span class="line"></span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) base();<span class="comment">//向下转型</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以调用子类类型中的<strong>所有成员</strong></li>
<li><strong>有向上转型之后才有向下转型</strong></li>
</ul>
<h5 id="多态细节"><a href="#多态细节" class="headerlink" title="多态细节"></a>多态细节</h5><ul>
<li>属性不能重写，属性的值由<strong>编译类型</strong>决定</li>
<li>方法可以重写，方法的值由<strong>运行类型</strong>决定</li>
<li><strong>属性看编译，方法看运行</strong></li>
<li><strong>instanceof 比较操作符</strong>，用于判断对象的<strong>运行类型</strong>是否为<strong>XX类型</strong>或者<strong>XX类型的子类型</strong></li>
</ul>
<h5 id="多态数组"><a href="#多态数组" class="headerlink" title="多态数组"></a>多态数组</h5><ul>
<li>数组<strong>定义为父类类型</strong>，<strong>储存类型为子类类型</strong></li>
</ul>
<h5 id="多态参数"><a href="#多态参数" class="headerlink" title="多态参数."></a>多态参数.</h5><ul>
<li>方法定义的<strong>形参类型为父类类型</strong>，<strong>实参类型可以为子类类型</strong></li>
</ul>
<h4 id="java的动态绑定机制"><a href="#java的动态绑定机制" class="headerlink" title="java的动态绑定机制"></a>java的动态绑定机制</h4><ul>
<li>当<strong>调用对象方法</strong>的时候，该方法会和该对象的<strong>内存地址&#x2F;运行类型</strong>绑定</li>
<li>当<strong>调用对象属性</strong>时，<strong>没有动态绑定机制</strong>，哪里声明，哪里使用<strong>（哪个类里声明就使用哪个类里的）</strong></li>
</ul>
<h4 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h4><ul>
<li>提高具有哈希结构的容器的效率</li>
<li>两个引用，如果指向的是同一个对象，则哈希值相同</li>
<li>两个引用，如果指向的是不同对象，则哈希值不相同</li>
<li><strong>哈希值主要是根据地址符号来的，不能完全将哈希值当作地址</strong></li>
<li>在集合中，hashCode如果需要的话也会重写</li>
<li><strong>java在JVM虚拟机上运行，不能得到具体的内存地址</strong></li>
</ul>
<h4 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h4><ul>
<li>默认返回：全类名 + @ + 哈希值的十六进制</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>子类往往重写toString方法，用于返回对象的属性信息</li>
<li>重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString方法</li>
<li>当直接输出一个对象时，toString方法默认调用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(person1);</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="comment">//System.out.println(person1.toString());</span></span><br></pre></td></tr></table></figure>

<h4 id="断点调试（debug）"><a href="#断点调试（debug）" class="headerlink" title="断点调试（debug）"></a>断点调试（debug）</h4><ul>
<li>断点调试过程中，<strong>是运行状态</strong>，是以对象的<strong>运行类型</strong>来执行的。</li>
<li>dubug可以帮助我们查看java底层源码，有助于提高水平</li>
<li><strong>F8</strong>逐行执行</li>
<li><strong>F7</strong>跳入方法内</li>
<li><strong>shift + F8</strong>跳出方法</li>
<li><strong>F9</strong>（resume）执行到下一个断点</li>
<li>IDEA支持在dubug过程中下新断点</li>
</ul>
<h4 id="类变量-x2F-类方法（static）"><a href="#类变量-x2F-类方法（static）" class="headerlink" title="类变量&#x2F;类方法（static）"></a>类变量&#x2F;类方法（static）</h4><ul>
<li><strong>类变量是所有该类对象共享的，而实例变量是给个对象独享的</strong></li>
<li>可以通过<strong>类名.类变量</strong>或者<strong>对象名.类变量</strong>名来访问</li>
<li><strong>类变量在类加载时产生，储存在堆里的静态域中</strong></li>
<li>类方法和普通方法都是<strong>随着类的加载而加载</strong>，将结构信息<strong>储存在方法区</strong></li>
<li>类方法中<strong>隐含着this的参数</strong></li>
<li>普通方法和对象有关，需要对象名调用</li>
<li>类方法<strong>不允许使用和对象有关的关键字</strong>，比如<strong>this</strong>和<strong>super</strong></li>
<li><strong>类方法中只能访问静态变量或静态方法</strong></li>
<li>普通成员方法，既可以访问普通变量（方法），也可以访问静态变量（方法）</li>
<li>编写代码时<strong>仍要遵守访问权限</strong></li>
<li><strong>可以将自己写的工具类写为类方法</strong></li>
</ul>
<h4 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h4><ul>
<li>由JVM调用，所以必须是public</li>
<li>由于不需要创建对象使用，所以必须是static</li>
<li>在程序运行时输入字符串数组，有空格时需要用引号</li>
<li>在main()方法中可以直接调用main方法所在类的静态方法或i静态属性</li>
</ul>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><ul>
<li>相当于<strong>另一种形式的构造器</strong>（对构造器的补充机制）</li>
<li>场景：如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的复用性</li>
<li>代码块的调用<strong>优先于构造器</strong></li>
<li><strong>静态代码块只能调用静态成员</strong>，<strong>普通代码块可以调用任意成员</strong>（静态在类加载时加载，非静态在创建对象时创建，因此静态不能调非静态）</li>
</ul>
<h4 id="静态代码块（static）"><a href="#静态代码块（static）" class="headerlink" title="静态代码块（static）"></a>静态代码块（static）</h4><ul>
<li>作用是对类进行初始化，而且它<strong>随着类的加载而执行</strong>，并且<strong>只会执行一次</strong></li>
<li>static没有动态绑定机制</li>
</ul>
<h4 id="非静态代码块"><a href="#非静态代码块" class="headerlink" title="非静态代码块"></a>非静态代码块</h4><ul>
<li>每创建一次对象就执行一次</li>
<li>在创建对象实例时，会被<strong>隐式的调用</strong>，被创建一次，就会被执行一次</li>
<li>如果只是使用类的静态成员时，普通代码块不会被执行</li>
</ul>
<h4 id="创建一个类对象时，在一个类调用顺序"><a href="#创建一个类对象时，在一个类调用顺序" class="headerlink" title="创建一个类对象时，在一个类调用顺序"></a>创建一个类对象时，在一个类调用顺序</h4><ol>
<li>调用<strong>静态代码块和静态属性初始化</strong>（先定义先调用）</li>
<li>调用<strong>普通代码块和普通属性的初始化</strong>（先定义先调用）</li>
<li>调用<strong>构造方法</strong>（构造器）</li>
<li>构造器最前面其实<strong>隐含了super()和调用普通代码块</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AAA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//(1)super()</span></span><br><span class="line">    <span class="comment">//(2)调用本类的普通代码块</span></span><br><span class="line">    System.out.println(<span class="string">&quot;AAA() 构造器被调用....&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建一个子类对象时（继承关系）优先级问题"><a href="#创建一个子类对象时（继承关系）优先级问题" class="headerlink" title="创建一个子类对象时（继承关系）优先级问题"></a>创建一个子类对象时（继承关系）优先级问题</h3><ol>
<li>父类的静态</li>
<li>子类的静态</li>
<li>父类的普通</li>
<li>父类构造方法</li>
<li>子类普通</li>
<li>子类构造方法</li>
</ol>
<ul>
<li>父子静、父普构、子普构</li>
</ul>
<h4 id="类什么时候被加载"><a href="#类什么时候被加载" class="headerlink" title="类什么时候被加载"></a>类什么时候被加载</h4><ul>
<li><strong>创建对象实例</strong>时（new）</li>
<li><strong>创建子类对象实例</strong>，父类也会被加载（理解为有了父代才有子代）</li>
<li><strong>使用静态成员</strong>时（静态属性、静态方法）</li>
</ul>
<h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><ul>
<li>采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法</li>
<li>构造器私有化-&gt;避免用户直接new</li>
<li>类的内部创建对象</li>
<li>向外暴露一个静态的公共方法</li>
</ul>
<h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GirlFriend</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="comment">//为了能够在静态方法中，返回 gf 对象，需要将其修饰为 static</span></span><br><span class="line"><span class="comment">//對象，通常是重量級的對象, 餓漢式可能造成創建了對象，但是沒有使用. </span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">GirlFriend</span> <span class="variable">gf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GirlFriend</span>(<span class="string">&quot;小红红&quot;</span>);</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GirlFriend</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//向外部暴露一个公共的static方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> GirlFriend <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> gf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">999</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Cat cat ; <span class="comment">//默認是 null</span></span><br><span class="line"><span class="comment">//步驟</span></span><br><span class="line"><span class="comment">//1.仍然構造器私有化</span></span><br><span class="line"><span class="comment">//2.定義一個 static 靜態屬性對象</span></span><br><span class="line"><span class="comment">//3.提供一個 public 的 static 方法，可以返回一個 Cat 對象</span></span><br><span class="line"><span class="comment">//4.懶漢式，只有當用戶使用 getInstance 時，才返回 cat 對象, 後面再次調用時，會返回上次創建的 cat 對象</span></span><br><span class="line"><span class="comment">// 從而保證了單例</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Cat</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;構造器調用...&quot;</span>);</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Cat <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(cat == <span class="literal">null</span>) &#123;<span class="comment">//如果還沒有創建 cat 對象</span></span><br><span class="line">			cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;小可愛&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cat;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="饿汉式vs懒汉式"><a href="#饿汉式vs懒汉式" class="headerlink" title="饿汉式vs懒汉式"></a>饿汉式vs懒汉式</h4><ul>
<li><p>最主要的区别在于创建对象的时机不同</p>
<ul>
<li>饿汉式是在类加载就创建了实例对象</li>
<li>懒汉式实在是使用时才创建</li>
</ul>
</li>
<li><p>饿汉式不存在线程安全问题，懒汉式存在线程安全问题</p>
</li>
<li><p>饿汉式存在浪费资源的可能，懒汉式是使用时才创建，就不存在这个问题</p>
</li>
</ul>
<h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><ul>
<li>可以修饰类、属性、方法和局部变量</li>
<li>使用场合<ul>
<li>当不希望类被继承是时</li>
<li>当不希望父类的某个方法被子类重写时</li>
<li>当不希望类的某个属性的值被修改时</li>
<li>当不希望某个局部变量被修改时</li>
</ul>
</li>
<li>final修饰的属性又叫常量，一般用XX_XX_XX来命名</li>
<li>final修饰的属性在定义时，必须赋初值，并且以后不能修改，赋值可以在以下位置之一：<ul>
<li>定义时：<code>public final double TAX_RATE = 0.08</code>（一般情况下使用这种）</li>
<li>在构造器中</li>
<li>在代码块中</li>
</ul>
</li>
<li>如果final修饰的属性是静态的，则初始化的位置只能是：<ul>
<li>定义时</li>
<li>在静态代码块中</li>
<li>不能在构造器中定义是因为静态属性在类加载时加载，而此时构造器为被调用，相当于没有赋值</li>
</ul>
</li>
<li>final类不能继承，但可以实例化对象</li>
<li>如果类不是final类，但是含有final方法，则该方法虽然不能重写，但可以被继承</li>
<li>一般来说，如果一个类已经是final类了，就没有必要再将方法修饰成final（因为该类已经不能被继承，方法自然不会被重写）</li>
<li>final不能修饰构造方法</li>
<li>final和static往往搭配使用，效率更高，不会导致类加载。底层编译器做了优化处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;该类被加载&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>包装类（Integer,Double,Float,Boolean）等都是final，String也是final类</li>
</ul>
<h3 id="抽象类（abstract）"><a href="#抽象类（abstract）" class="headerlink" title="抽象类（abstract）"></a>抽象类（abstract）</h3><ul>
<li>当父类的某些方法，需要声明，但又不确定如何实现时，可以将其声明为抽象方法，那么这个类就是抽象类</li>
<li>用abstract关键字修饰一个类时，这个类就叫抽象类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">abstract</span> 类名&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>用abstract关键字来修饰一个方法时，这个方法就是抽象方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">abstract</span> 返回类型 方法名(参数列表);<span class="comment">//没有方法体</span></span><br></pre></td></tr></table></figure>

<ul>
<li>抽象类的价值更多作用是在于设计，是设计者设计好后，用子类继承实现抽象类()</li>
<li>抽象类是考官比较爱问的知识点，在框架和设计模式使用较多</li>
</ul>
<h4 id="抽象类使用的注意事项和细节"><a href="#抽象类使用的注意事项和细节" class="headerlink" title="抽象类使用的注意事项和细节"></a>抽象类使用的注意事项和细节</h4><ul>
<li>抽象类<strong>不能被实例化</strong></li>
<li>抽象类不一定包含abstract方法。也就是说，<strong>抽象类可以不包含abstract方法</strong></li>
<li><strong>一旦类包含了acstract方法，则这个类必须声明为abstract</strong></li>
<li>abstact<strong>只能修饰类和方法</strong>，<strong>不能修饰属性和其他的</strong></li>
<li><strong>抽象类可以有任意成员</strong>【抽象类本质还是类】</li>
<li>抽象方法<strong>不能有主体</strong>，即不能实现（没有花括号）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">aaa</span><span class="params">()</span>;<span class="comment">//&#123;&#125;;-&gt;有花括号就代表实现了方法</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果一个类继承了抽象类，则它<strong>必须实现抽象类的所有方法</strong>，除非它自己也声明为abstract类</li>
<li>抽象方法不能使用<strong>private</strong>、<strong>final</strong>、<strong>static</strong>来修饰，因为这些关键字都是和重写相违背的<ul>
<li>private：方法私有化后子类无法重写</li>
<li>final：final关键字修饰后的方法不能被重写</li>
<li>static：<strong>static方法必须有方法体，static没有动态绑定机制</strong></li>
</ul>
</li>
</ul>
<h3 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h3><ul>
<li>接口就是<strong>给出一些没有实现的方法</strong>,封装到一起，起到某个类要使用的时候，再根据具体情况把这些方法写出来</li>
<li>语法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名&#123;</span><br><span class="line">	<span class="comment">//属性</span></span><br><span class="line">	<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 类名 implements 接口&#123;</span><br><span class="line">	<span class="comment">//自己属性</span></span><br><span class="line">	<span class="comment">//自己方法</span></span><br><span class="line">	<span class="comment">//必须实现的接口的抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>接口不能被实例化</strong></li>
<li>接口中<strong>所有的方法是public方法</strong>，<strong>接口中抽象方法，可以不用abstract修饰</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">aaa</span><span class="params">()</span>;</span><br><span class="line">实际上是 <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">aaa</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个普通类实现接口，就必须将该接口的所有方法都实现</li>
<li><strong>抽象类实现接口，可以不用实现接口的方法</strong></li>
<li>一个类同时可以实现多个接口</li>
<li><strong>接口中的属性，只能是final的</strong>，而且是<code>public static final</code>修饰符。比如<code>int a = 1</code>;实际上是<code>public static final int a = 1</code>;（必须初始化）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220321213601330.png" alt="image-20220321213601330"></p>
<ul>
<li>接口中属性的访问形式：接口名.属性名</li>
<li><strong>接口不能继承其他的类</strong>，但<strong>可以继承多个接口</strong></li>
<li><strong>接口的修饰符只能是public和默认，这点和类的修饰符是一样的</strong></li>
<li>可以理解接口是**java单继承的一种补充机制   **</li>
</ul>
<h3 id="接口（interface）vs-继承（entends）"><a href="#接口（interface）vs-继承（entends）" class="headerlink" title="接口（interface）vs 继承（entends）"></a>接口（interface）vs 继承（entends）</h3><ul>
<li>接口和继承解决的问题不同</li>
<li><strong>继承的价值主要在于：解决代码的复用性和可维护性</strong></li>
<li><strong>接口的价值主要在于：设计，设计好各种规范（方法），让其他类去实现这些方法。即更加灵活</strong></li>
<li>接口比继承更加<strong>灵活</strong></li>
<li>继承是满足<strong>is-a</strong>的关系，接口只需满足<strong>like-a</strong>的关系</li>
<li>接口在一定程度上实现<strong>代码解耦</strong>【即：接口规范性+动态绑定机制】</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.interface_;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceExercise02</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123; <span class="comment">// 1min 看看</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">//想到 等价 public static final int x = 0;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="comment">//普通属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pX</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//System.out.println(x); //错误，原因不明确 x</span></span><br><span class="line">    <span class="comment">//可以明确的指定 x</span></span><br><span class="line">    <span class="comment">//访问接口的 x 就使用 A.x</span></span><br><span class="line">    <span class="comment">//访问父类的 x 就使用 super.x</span></span><br><span class="line">    	System.out.println(A.x + <span class="string">&quot; &quot;</span> + <span class="built_in">super</span>.x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">C</span>().pX(); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部类（innerClass）"><a href="#内部类（innerClass）" class="headerlink" title="内部类（innerClass）"></a>内部类（innerClass）</h3><ul>
<li>定义在局部位置：（1）局部内部类；（2）匿名内部类</li>
<li>定义在成员位置：（1）成员内部类；（2）静态内部类</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220321214148685.png" alt="image-20220321214148685"></p>
<h4 id="局部内部类（本质仍是一个类）"><a href="#局部内部类（本质仍是一个类）" class="headerlink" title="局部内部类（本质仍是一个类）"></a>局部内部类（本质仍是一个类）</h4><ul>
<li>可以<strong>直接访问外部类的所有成员，包括私有的</strong></li>
<li><strong>不能添加访问修饰符</strong>，因为为它的地位就是一个局部变量，但<strong>可以用final关键字修饰</strong></li>
<li>作用域：仅仅在定义它的方法或代码块中</li>
<li>局部——-&gt;访问——–&gt;外部类的成员【访问方式：直接访问】</li>
<li><strong>外部类——–&gt;访问———&gt;局部内部类的成员【访问方式：创建对象，再访问，必须在作用域内】</strong></li>
<li><strong>外部其他类——–&gt;不能访问——-&gt;局部内部类（因为局部内部类的地位是局部变量）</strong></li>
<li>如果<strong>外部类和局部内部类的成员重名时</strong>，默认<strong>遵循就近原则</strong>，如果想访问外部类的成员，可以使用<code>外部类名.this.成员</code>去访问</li>
</ul>
<p><code>System.out.println(&quot;外部类的n2 = &quot; + 外部类名.this.n2);</code></p>
<ul>
<li><strong>外部类名.this表示的是哪个对象调用的方法就是哪个类</strong>（可以用hashCode()验证）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outter01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outter</span> <span class="variable">outter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>();</span><br><span class="line">        outter.f1();</span><br><span class="line">        System.out.println(<span class="string">&quot;outter的hashCode = &quot;</span> + outter.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outter</span> &#123;<span class="comment">//外部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;秀吉&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;<span class="comment">//在方法中创建对象然后调用</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;<span class="comment">//内部类</span></span><br><span class="line">            <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;小白&quot;</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;外部类的name属性 = &quot;</span> + Outter.<span class="built_in">this</span>.name);</span><br><span class="line">                System.out.println(<span class="string">&quot;Outter.this的hashCode = &quot;</span> + Outter.<span class="built_in">this</span>.hashCode());</span><br><span class="line">                System.out.println(<span class="string">&quot;局部内部类的name属性 = &quot;</span> + name);<span class="comment">//就近原则</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.say();</span><br><span class="line">        System.out.println(<span class="string">&quot;局部内部类的name属性 = &quot;</span> + inner.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><ul>
<li>（1）本质是类；（2）内部类；（3）该类没有名字；（4）同时还是一个对象</li>
<li>说明：匿名内部类是定义在外部类的局部位置，比如方法中，并且没有类名（jdk在底层自动分配类名，<code>类名$n</code>）</li>
<li>匿名内部类的基本语法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类或接口(参数列表)&#123;</span><br><span class="line">	类体</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于接口的匿名内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span>&#123;</span><br><span class="line">    	<span class="comment">//tiger的编译类型是IA</span></span><br><span class="line">    	<span class="comment">//运行类型是Outer$1</span></span><br><span class="line">        <span class="type">IA</span> <span class="variable">tiger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IA</span>()&#123;<span class="comment">//当成对象使用并且接收</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;小老虎呜呜呜~~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        tiger.say();</span><br><span class="line">        tiger.say();</span><br><span class="line">        tiger.say();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">IA</span>()&#123;<span class="comment">//直接当作对象使用并且不接收对象</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;小鸟叽叽叽~~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.say();</span><br><span class="line">        System.out.println(tiger.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于类的匿名内部类</span></span><br><span class="line"><span class="comment">//演示基于类的匿名内部类</span></span><br><span class="line"><span class="comment">//分析</span></span><br><span class="line"><span class="comment">//1. father 编译类型 Father</span></span><br><span class="line"><span class="comment">//2. father 运行类型 Outer04$2</span></span><br><span class="line"><span class="comment">//3. 底层会创建匿名内部类</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Outer04$2 extends Father&#123;</span></span><br><span class="line"><span class="comment">    @Override</span></span><br><span class="line"><span class="comment">    public void test() &#123;</span></span><br><span class="line"><span class="comment">    	System.out.println(&quot;匿名内部类重写了 test 方法&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//4. 同时也直接返回了 匿名内部类 Outer04$2 的对象</span></span><br><span class="line"><span class="comment">//5. 注意(&quot;jack&quot;) 参数列表会传递给 构造器</span></span><br><span class="line"><span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>(<span class="string">&quot;jack&quot;</span>)&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;匿名内部类重写了 test 方		法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;father 对象的运行类型=&quot;</span> + father.getClass());<span class="comment">//Outer04$2</span></span><br><span class="line">father.test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;<span class="comment">//类</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Father</span><span class="params">(String name)</span> &#123;<span class="comment">//构造器</span></span><br><span class="line">		System.out.println(<span class="string">&quot;接收到 name=&quot;</span> + name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;<span class="comment">//方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于抽象类的匿名内部类</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;小狗吃骨头...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">animal.eat();</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123; <span class="comment">//抽象类</span></span><br><span class="line">	<span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>匿名内部类只能使用一次就不能再使用了</strong></li>
<li>匿名内部类<strong>既是一个类的定义</strong>，<strong>同时本身也是一个对象</strong></li>
<li>语法上既有定义类的特征，也有创建对象的特征</li>
<li><strong>可以访问外部类的所有成员，包括私有的</strong></li>
<li><strong>不能添加访问修饰符</strong>，地位是一个<strong>局部变量</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.innerclass;</span><br><span class="line"><span class="keyword">import</span> com.hspedu.abstract_.AA;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClassExercise01</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//当做实参直接传递，简洁高效</span></span><br><span class="line">    f1(<span class="keyword">new</span> <span class="title class_">IL</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;这是一副名画~~...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">        </span><br><span class="line">	<span class="comment">//传统方法</span></span><br><span class="line">    f1(<span class="keyword">new</span> <span class="title class_">Picture</span>());</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态方法,形参是接口类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(IL il)</span> &#123;</span><br><span class="line">    	il.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IL</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类-&gt;实现 IL =&gt; 编程领域 (硬编码)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Picture</span> <span class="keyword">implements</span> <span class="title class_">IL</span> &#123;<span class="comment">//需要创建一个类，并且难以维护</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;这是一副名画 XX...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><ul>
<li>定义在外部类的成员位置，<strong>并且没有static修饰</strong></li>
<li>可以<strong>直接访问外部类的所有成员</strong></li>
<li>可以添加任意访问修饰符，<strong>地位就是一个成员</strong></li>
<li>作用域和外部类的其他成员一样，为整个类体</li>
<li>在外部类的成员方法中创建内部类对象，再调用方法</li>
<li><strong>成员内部类—&gt;访问—–&gt;外部类成员【访问方式：直接访问】</strong></li>
<li><strong>外部类—–&gt;访问——-&gt;成员内部类【访问方式：创建对象，在访问】（单独写一个方法创建对象，再使用成员）</strong></li>
<li><strong>外部其他类——–&gt;访问——&gt;成员内部类</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方法</span></span><br><span class="line">Outter.<span class="type">inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>().<span class="keyword">new</span> <span class="title class_">inner</span>();</span><br><span class="line"><span class="comment">//第二种方法</span></span><br><span class="line">Outter.<span class="type">Inner</span> <span class="variable">innerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>().getInnerClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outter</span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInnerClass</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类成员，则可以使用【外部类名.this.成员】去访问</li>
</ul>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><ul>
<li>可以直接访问外部类的所有静态成员，包含私有的</li>
<li>可以添加任意访问修饰符，地位是一个成员</li>
<li>作用域：同其他成员，为整个类体</li>
<li>静态内部类—-&gt;访问——&gt;外部类【访问方式：直接访问静态成员】</li>
<li>外部类—–&gt;访问—–&gt;静态内部类【访问方式：先创建对象，再访问】</li>
<li>外部其他类——&gt;访问——&gt;静态内部类【访问方式：同其他静态成员】</li>
<li>如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类成员，则可以使用【外部类名.成员】去访问</li>
</ul>
<h3 id="枚举类（enumeration）"><a href="#枚举类（enumeration）" class="headerlink" title="枚举类（enumeration）"></a>枚举类（enumeration）</h3><ul>
<li>枚举是一组常量的集合</li>
<li>可以理解为：枚举属于一种特殊的类，里面只包含一组有限的特定对象</li>
<li>枚举的两种实现方式：（1）自定义类实现枚举；（2）使用enum关键字实现枚举</li>
</ul>
<h4 id="自定义类实现枚举"><a href="#自定义类实现枚举" class="headerlink" title="自定义类实现枚举"></a>自定义类实现枚举</h4><ul>
<li>不需要提供setXXX方法，因为枚举对象通常为只读</li>
<li>对枚举对象&#x2F;属性使用<code>final + static</code>共同修饰，实现底层优化</li>
<li>枚举对象名通常使用全部大写，常量的命名规范</li>
<li>枚举对象根据需要，也可以有多个属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span> &#123;<span class="comment">//类</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;<span class="comment">//描述</span></span><br><span class="line">    <span class="comment">//定义了四个对象, 固定. public static final Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;);</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;寒冷&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;凉爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;炎热&quot;</span>);</span><br><span class="line">    <span class="comment">//1. 将构造器私有化,目的防止 直接 new</span></span><br><span class="line">    <span class="comment">//2. 去掉 setXxx 方法, 防止属性被修改</span></span><br><span class="line">    <span class="comment">//3. 在 Season 内部，直接创建固定的对象</span></span><br><span class="line">    <span class="comment">//4. 优化，可以加入 final 修饰符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;, desc=&#x27;&quot;</span> + desc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>特点：<ul>
<li>构造器私有化</li>
<li>本类内部创建一组对象</li>
<li>对外暴露对象（通过为对象添加<code>public final static</code>修饰符）</li>
<li>可以提供get方法，但是不要提供set方法</li>
</ul>
</li>
</ul>
<h4 id="enum关键字实现枚举"><a href="#enum关键字实现枚举" class="headerlink" title="enum关键字实现枚举"></a>enum关键字实现枚举</h4><ul>
<li>当使用enum关键字开发一个枚举类时，默认会继承Enum类，而且是一个final类（可以使用javap工具查看）</li>
<li>传统的 <code>public static final Season2 SPRING = new Season2(&quot;春天&quot;, &quot;温暖&quot;);</code> 简化成 <code>SPRING(&quot;春天&quot;, &quot;温暖&quot;)</code>， 这里必须知道，它调用的是哪个构造器</li>
<li>如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略</li>
<li>当有多个枚举对象时，使用<code>,</code>间隔，最后有一个分号结尾</li>
<li>枚举对象必须放在枚举类的行首</li>
<li><strong>Enum类的常用方法</strong><ul>
<li><strong>toString:Enum 类已经重写过了</strong>，返回的是当前对象 名,子类可以重写该方法，用于返回对象的属性信息</li>
<li>name：返回当前对象名（常量名），子类中不能重写</li>
<li>ordinal：返回当前对象的位置号，默认从 0 开始</li>
<li>values：返回当前枚举类中所有的常量</li>
<li><strong>valueOf：将字符串转换成枚举对象，要求字符串必须 为已有的常量名，否则报异常！</strong></li>
<li><strong>compareTo：比较两个枚举常量，比较的就是编号！（Enum01.ordinal() - Enum02.ordinal()</strong></li>
</ul>
</li>
</ul>
<h4 id="enum实现接口"><a href="#enum实现接口" class="headerlink" title="enum实现接口"></a>enum实现接口</h4><ul>
<li><strong>使用enum关键字后，就不能再继承其他类了</strong>，因为<strong>会默认隐式继承Enum类</strong>，而java时单继承机制</li>
<li><strong>枚举类和普通类一样，可以实现接口</strong>，形式如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> 类名 implements 接口<span class="number">1</span>,接口<span class="number">2</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumDetail</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	Music.CLASSICMUSIC.playing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPlaying</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playing</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Music</span> <span class="keyword">implements</span> <span class="title class_">IPlaying</span> &#123;</span><br><span class="line">    CLASSICMUSIC;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playing</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;播放好听的音乐...&quot;</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注解（Annotation）"><a href="#注解（Annotation）" class="headerlink" title="注解（Annotation）"></a>注解（Annotation）</h3><ul>
<li><p>也被称为元数据（Metadata），用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息</p>
</li>
<li><p>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息</p>
</li>
<li><p>在javaSE中，注解的使用目的比较简单，例如标注果实的功能，忽略警告等</p>
</li>
<li><p>在javaEE中注解占据了更重要的角色，例如来配置应用程序的如何切面，代替javaEE旧版中所遗留的繁冗代码和XML配置等</p>
</li>
<li><p>三个基本的Annotation：</p>
<ul>
<li><p>@Override：限定某个方法，是重写父类方法，该注解只能用于方法</p>
<ul>
<li>如果你写了@Override 注解，编译器就会去检查该方法是否真的重写了父类的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span><span class="comment">//说明只能用于修饰方法</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;<span class="comment">//@interface表示一个注解类</span></span><br><span class="line"><span class="comment">//@Target时修饰注解的注解，称为元注解</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>@Deprecated：用于表示某个程序元素（类，方法等）已过时</p>
<ul>
<li>@Deprecated的作用可以做到新旧版本的兼容和过渡</li>
</ul>
</li>
<li><p>@SuppressWarnings：抑制编译器警告</p>
</li>
</ul>
</li>
</ul>
<h3 id="异常（Exception）"><a href="#异常（Exception）" class="headerlink" title="异常（Exception）"></a>异常（Exception）</h3><ul>
<li>程序执行中发生的不正常情况称为”异常”</li>
<li>语法错误和逻辑错误不是异常</li>
<li>执行过程中所发生的与i长课分为两大类：<code>Error</code>、<code>Exception</code></li>
</ul>
<h4 id="错误（Error）"><a href="#错误（Error）" class="headerlink" title="错误（Error）"></a>错误（Error）</h4><ul>
<li>java虚拟机无法解决的严重问题，程序会崩溃<ul>
<li>StackOverflowError（栈溢出）</li>
<li>OOM（out of memeory）</li>
</ul>
</li>
</ul>
<h4 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h4><ul>
<li>编译错误或偶然的外在因素导致的一般性问题，可以针对代码进行处理</li>
<li>分为两大类：运行时异常【程序运行时，发生的异常】、编译时异常【编译时，编译器检查出的异常】</li>
</ul>
<h4 id="异常体系图"><a href="#异常体系图" class="headerlink" title="异常体系图"></a>异常体系图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220326110633960.png" alt="image-20220326110633960"></p>
<ul>
<li>运行时异常，编译器检查不出来，一般指编程时的逻辑错误，是程序应该避免其出现的异常。<code>java.lang.RuntimeException</code>类以及它的子类都是运行时异常</li>
<li>运行时异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响</li>
<li>编译时异常，是编译器要求必须处置的异常</li>
</ul>
<h4 id="常见的运行时异常"><a href="#常见的运行时异常" class="headerlink" title="常见的运行时异常"></a>常见的运行时异常</h4><ul>
<li><strong>NullPointerException 空指针异常</strong><ul>
<li>应用程序试图在需要对象的地方使用null时</li>
<li>例如：null调用length方法时</li>
</ul>
</li>
<li><strong>ArrayIndexOutBoundsException 数组下标越界异常</strong><ul>
<li>用非法索引访问数组时抛出的异常</li>
<li>例如：所引为负或大于数组长度</li>
</ul>
</li>
<li><strong>ClassCastException 类型转换异常</strong><ul>
<li>试图将对象强制转换为不是实例的子类时</li>
</ul>
</li>
<li><strong>ArithmeticException 数学运算异常</strong><ul>
<li>出现异常的 运算条件</li>
<li>例如：一个数除以0</li>
</ul>
</li>
<li><strong>NumberFormatException 数字格式不正确异常</strong><ul>
<li>应用程序试图将字符串转换成一种数值类型，但该字符串不能转化成适当格式时</li>
<li>例如：<code>int a = Integer.parseInt(&quot;a123&quot;);</code></li>
</ul>
</li>
</ul>
<h4 id="常见的编译时异常"><a href="#常见的编译时异常" class="headerlink" title="常见的编译时异常"></a>常见的编译时异常</h4><ul>
<li>SQLException 错做数据库时，查询表可能发生异常</li>
<li>IOException 操作文件时，发生的异常</li>
<li>FileNotFountException 当加载一个不存在的文件时发生的异常</li>
<li>ClassNotfoundException 当加载一个不存在的类时发生的异常</li>
<li>EOFException 操作文件，到文件末尾时，发生异常</li>
<li>IIIlegalArguementException 参数异常</li>
</ul>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><ul>
<li>程序员在代码中捕获发生的异常，自行处理</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220326112729490.png" alt="image-20220326112729490"></p>
<ul>
<li>语法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> num1 / num2;<span class="comment">//可疑代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;<span class="comment">//将捕获的异常传给e</span></span><br><span class="line">	System.out.println(e.getMessage());</span><br><span class="line">	<span class="comment">//异常处理</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="comment">//不管是否发生异常，始终执行的代码~~~</span></span><br><span class="line">    <span class="comment">//释放资源等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果异常发生了，则异常后面的代码不会执行，直接进入到catch块</li>
<li>可以有多个catch，捕获不同的异常</li>
<li>要求子类异常在前，父类异常在后</li>
<li>如果发生异常，只会匹配到一个catch</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220326114259025.png" alt="image-20220326114259025"></p>
<ul>
<li>catch块内return后的语句会执行，但不会立刻返回，会将数据储存在一个临时变量中，等待fanally块中的语句执行完再返回</li>
</ul>
<h4 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h4><ul>
<li>将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是JVM</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220326112755417.png" alt="image-20220326112755417"></p>
<ul>
<li>如果一个方法（语句执行时）可能生成某种异常，但能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由方法的调用者进行处理</li>
<li>在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f3</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> 				<span class="title class_">FileInputStream</span>(<span class="string">&quot;d://aa.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><ul>
<li>当程序中出现了某些”错误”，但该错误信息并没有再Throwable子类描述处理，这个时候可以自己设计异常类，用于描述该错误信息</li>
<li>步骤：<ul>
<li>定义类：自定义异常类名继承Exception或RuntimeException</li>
<li>如果继承Exception，属于编译异常</li>
<li>如果继承RuntimeException，属于运行异常【一般继承Exception】</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AgeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeException</span><span class="params">(String message)</span> &#123;<span class="comment">//构造器</span></span><br><span class="line">    	<span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="comment">/*throws AgeException*/</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">180</span>;</span><br><span class="line">        <span class="comment">//要求范围在 18 – 120 之间，否则抛出一个自定义异常</span></span><br><span class="line">        <span class="keyword">if</span>(!(age &gt;= <span class="number">18</span> &amp;&amp; age &lt;= <span class="number">120</span>)) &#123;</span><br><span class="line">            <span class="comment">//这里我们可以通过构造器，设置信息</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeException</span>(<span class="string">&quot;年龄需要在 18~120 之间&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;你的年龄范围正确.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="throw-和throws-的区别"><a href="#throw-和throws-的区别" class="headerlink" title="throw 和throws 的区别"></a>throw 和throws 的区别</h4><table>
<thead>
<tr>
<th></th>
<th>意义</th>
<th>位置</th>
<th align="center">后面跟的东西</th>
</tr>
</thead>
<tbody><tr>
<td>throws</td>
<td>异常处理的一种处理方式</td>
<td>方法声明中</td>
<td align="center">异常类型</td>
</tr>
<tr>
<td>throw</td>
<td>手动生成异常对象的关键字</td>
<td>方法体中</td>
<td align="center">###异常对象</td>
</tr>
</tbody></table>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><h4 id="Integer类（数学类型）"><a href="#Integer类（数学类型）" class="headerlink" title="Integer类（数学类型）"></a>Integer类（数学类型）</h4><ul>
<li>jdk5以前：手动装拆箱</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手动装箱 int-&gt;Integer</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(n1);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> Integer.valueOf(n1);</span><br><span class="line"><span class="comment">//手动拆箱</span></span><br><span class="line"><span class="comment">//Integer -&gt; int</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> integer.intValue();</span><br></pre></td></tr></table></figure>

<ul>
<li>jdk5以后：自动装拆箱</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jdk5 后，就可以自动装箱和自动拆箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="comment">//自动装箱 int-&gt;Integer</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer2</span> <span class="operator">=</span> n2; <span class="comment">//底层使用的是 Integer.valueOf(n2)</span></span><br><span class="line"><span class="comment">//自动拆箱 Integer-&gt;int</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> integer2; <span class="comment">//底层仍然使用的是 intValue()方法</span></span><br></pre></td></tr></table></figure>

<h4 id="包装类-gt-String"><a href="#包装类-gt-String" class="headerlink" title="包装类-&gt;String"></a>包装类-&gt;String</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包装类(Integer)-&gt;String</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//自动装箱</span></span><br><span class="line"><span class="comment">//方式 1</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">//方式 2</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> i.toString();</span><br><span class="line"><span class="comment">//方式 3</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line"><span class="comment">//String -&gt; 包装类(Integer)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.parseInt(str4);<span class="comment">//使用到自动装箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(str4);<span class="comment">//构造器</span></span><br></pre></td></tr></table></figure>

<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="Integer-x2F-Character类"><a href="#Integer-x2F-Character类" class="headerlink" title="Integer&#x2F;Character类"></a>Integer&#x2F;Character类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.MIN_VALUE); <span class="comment">//返回最小值</span></span><br><span class="line">System.out.println(Integer.MAX_VALUE);<span class="comment">//返回最大值</span></span><br><span class="line">System.out.println(Character.isDigit(<span class="string">&#x27;a&#x27;</span>));<span class="comment">//判断是不是数字</span></span><br><span class="line">System.out.println(Character.isLetter(<span class="string">&#x27;a&#x27;</span>));<span class="comment">//判断是不是字母</span></span><br><span class="line">System.out.println(Character.isUpperCase(<span class="string">&#x27;a&#x27;</span>));<span class="comment">//判断是不是大写</span></span><br><span class="line">System.out.println(Character.isLowerCase(<span class="string">&#x27;a&#x27;</span>));<span class="comment">//判断是不是小写</span></span><br><span class="line">System.out.println(Character.isWhitespace(<span class="string">&#x27;a&#x27;</span>));<span class="comment">//判断是不是空格</span></span><br><span class="line">System.out.println(Character.toUpperCase(<span class="string">&#x27;a&#x27;</span>));<span class="comment">//转成大写</span></span><br><span class="line">System.out.println(Character.toLowerCase(<span class="string">&#x27;A&#x27;</span>));<span class="comment">//转成小写</span></span><br></pre></td></tr></table></figure>

<h5 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h5><ul>
<li>new Integer()创建新对象</li>
<li>Integer i &#x3D; 1<ul>
<li>若范围在<code>-128~127</code>直接从数组返回</li>
<li>否则new Integer()</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">    <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;<span class="comment">//IntegerCache.low(-128)~IntegerCache.high(127)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>只要有基本数据类型，判断值是否相等</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer i11=<span class="number">127</span>;</span><br><span class="line"><span class="type">int</span> i12=<span class="number">127</span>;</span><br><span class="line"><span class="comment">//只有有基本数据类型，判断的是</span></span><br><span class="line"><span class="comment">//值是否相同</span></span><br><span class="line">System.out.println(i11==i12); <span class="comment">//T</span></span><br></pre></td></tr></table></figure>

<h4 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h4><ul>
<li>String对象用于保存字符串，也就是一组字符序列</li>
<li>字符串的字符使用Unicode字符编码，一个字符占两个字节</li>
<li>常用的构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(String original);</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] a);</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] a,<span class="type">int</span> startIndex,<span class="type">int</span> count);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>实现了Serializable接口：可以串行化（进行网络传输）</strong></li>
<li>实现了Comparable接口：可以进行比较</li>
<li>是final 类，不能被继承</li>
<li>String 有属性**private final char value[];**用于存放字符串内容</li>
<li>value是一个final属性，即不能指向新的<strong>地址</strong>，<strong>单个字符</strong>可以修改</li>
</ul>
<h5 id="创建String对象的两种方式"><a href="#创建String对象的两种方式" class="headerlink" title="创建String对象的两种方式"></a>创建String对象的两种方式</h5><ul>
<li>直接赋值：<code>String s1 = &quot;Asahi&quot;;</code></li>
<li>调用构造器：<code>String s2 = new String(&quot;Asahi&quot;);</code></li>
<li>两者区别<ul>
<li>方法一（直接赋值）：先查看常量池中是否有”Asahi”数据空间，如果有，则直接指向；如果没有，则重新创建，然后指向，s最终指向的是<strong>常量池的空间地址</strong></li>
<li>方法二（构造器创建）: 先在堆中创建空间，里面维护了value属性，指向常量池的”Asahi”空间。如果池中有，则valur直接指向；如果没有，则重新创建，然后指向</li>
</ul>
</li>
<li>内存分布图</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220403160811926.png" alt="image-20220403160811926"></p>
<ul>
<li>调用**inter()**方法时，返回池中的地址</li>
<li><code>String a = &quot;hello&quot; + &quot;java&quot;</code>创建一个对象，编译器会判断是否有引用指向</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;java&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line"><span class="comment">//创建了三个对象</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>底层是</p>
<ul>
<li>StringBuilder sb &#x3D; new StringBuilder();</li>
<li>sb.append(a);</li>
<li>sb.append(b);</li>
</ul>
</li>
<li><p><strong>重要规则，常量相加，看的是池，变量相加，看的是堆</strong></p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220403162524143.png" alt="image-20220403162524143"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220403162537073.png" alt="image-20220403162537073"></p>
<h5 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>equals 比较内容是否相同，区分大小写</span><br><span class="line"><span class="number">2.</span>equalsIgnoreCase 忽略大小写的判断内容是否相等</span><br><span class="line"><span class="number">3.</span>length 获取字符的个数，字符串的长度</span><br><span class="line"><span class="number">4.</span>indexOf 获取字符在字符串对象中第一次出现的索引，索引从 <span class="number">0</span> 开始，如果找不到</span><br><span class="line"><span class="number">5.</span>lastIndexOf 获取字符在字符串中最后一次出现的索引，索引从 <span class="number">0</span> 开始，如果找不</span><br><span class="line"><span class="number">6.</span>substring 截取指定范围的子：name.substring(<span class="number">0</span>,<span class="number">5</span>)表示从索引 <span class="number">0</span> 开始截取，截取到索引 <span class="number">5</span>-<span class="number">1</span>=<span class="number">4</span> 位</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>toUpperCase 转换成大写</span><br><span class="line"><span class="number">2.</span>toLowerCase 转换成和小写</span><br><span class="line"><span class="number">3.</span>concat 拼接字符串</span><br><span class="line"><span class="number">4.</span>replace 替换字符串中的字符</span><br><span class="line"><span class="number">5.</span>split 分割字符串, 对于某些分割字符，我们需要 转义比如 | \\等</span><br><span class="line">String[] split = poem.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">poem = <span class="string">&quot;E:\\aaa\\bbb&quot;</span>;</span><br><span class="line">split = poem.split(<span class="string">&quot;\\\\&quot;</span>);</span><br><span class="line"><span class="number">7.</span>compareTo 比较两个字符串的大小，如果前者大，则返回正数，后者大，则返回负数，如果相等，返回 <span class="number">0</span></span><br><span class="line"><span class="number">8.</span>format 格式字符串，%<span class="number">.2f</span>会进行四舍五入</span><br><span class="line"><span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span></span><br><span class="line"><span class="string">&quot;我的姓名是&quot;</span> + name + <span class="string">&quot;年龄是&quot;</span> + age + <span class="string">&quot;,成绩是&quot;</span> + score + <span class="string">&quot;性别是&quot;</span> + gender + <span class="string">&quot;。希望大家喜欢我！</span></span><br><span class="line"><span class="string">&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220403232323530.png" alt="image-20220403232323530"></p>
<h4 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h4><ul>
<li>StringBuffer 的直接父类 是 AbstractStringBuilder</li>
<li>实现了Serializable，即可以串行化</li>
<li>在父类AbstactStringBuilder有属性<code>char[] value</code>,不是 final</li>
<li>是一个final类</li>
<li>字符内容存在<code>char[] value</code>中，故不是每次修改都要更换地址，效率高于String</li>
<li>方法都有synchronized修饰，是线程安全的</li>
</ul>
<h4 id="String和SrtingBuffer的转化"><a href="#String和SrtingBuffer的转化" class="headerlink" title="String和SrtingBuffer的转化"></a>String和SrtingBuffer的转化</h4><h5 id="String-gt-SrtingBuffer"><a href="#String-gt-SrtingBuffer" class="headerlink" title="String-&gt;SrtingBuffer"></a>String-&gt;SrtingBuffer</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello tom&quot;</span>;</span><br><span class="line"><span class="comment">//方式 1 使用构造器</span></span><br><span class="line"><span class="comment">//注意： 返回的才是 StringBuffer 对象，对 str 本身没有影响</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str);</span><br><span class="line"><span class="comment">//方式 2 使用的是 append 方法</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">stringBuffer1 = stringBuffer1.append(str);</span><br></pre></td></tr></table></figure>

<h5 id="SrtingBuffer-gt-String"><a href="#SrtingBuffer-gt-String" class="headerlink" title="SrtingBuffer-&gt;String"></a>SrtingBuffer-&gt;String</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;韩顺平教育&quot;</span>);</span><br><span class="line"><span class="comment">//方式 1 使用 StringBuffer 提供的 toString 方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringBuffer3.toString();</span><br><span class="line"><span class="comment">//方式 2: 使用构造器来搞定</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(stringBuffer3);</span><br></pre></td></tr></table></figure>

<h5 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//增</span></span><br><span class="line">s.append(<span class="string">&#x27;,&#x27;</span>);<span class="comment">// &quot;hello,&quot;</span></span><br><span class="line"><span class="comment">//删</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 删除索引为&gt;=start &amp;&amp; &lt;end 处的字符</span></span><br><span class="line"><span class="comment">* 解读: 删除 11~14 的字符 [11, 14)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">s.delete(<span class="number">11</span>, <span class="number">14</span>);</span><br><span class="line">System.out.println(s);<span class="comment">//&quot;hello,张三丰赵敏 true10.5&quot;</span></span><br><span class="line"><span class="comment">//改</span></span><br><span class="line"><span class="comment">//老韩解读，使用 周芷若 替换 索引 9-11 的字符 [9,11)</span></span><br><span class="line">s.replace(<span class="number">9</span>, <span class="number">11</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">System.out.println(s);<span class="comment">//&quot;hello,张三丰周芷若 true10.5&quot;</span></span><br><span class="line"><span class="comment">//查 </span></span><br><span class="line"><span class="comment">//插找指定的子串在字符串第一次出现的索引，如果找不到返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">indexOf</span> <span class="operator">=</span> s.indexOf(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">System.out.println(indexOf);<span class="comment">//6 </span></span><br><span class="line"><span class="comment">//插</span></span><br><span class="line"><span class="comment">//老韩解读，在索引为 9 的位置插入 &quot;赵敏&quot;,原来索引为 9 的内容自动后移</span></span><br><span class="line">s.insert(<span class="number">9</span>, <span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">System.out.println(s);<span class="comment">//&quot;hello,张三丰赵敏周芷若 true10.5&quot;</span></span><br><span class="line"><span class="comment">//长度</span></span><br><span class="line">System.out.println(s.length());<span class="comment">//22</span></span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<h4 id="SrtingBuilder类"><a href="#SrtingBuilder类" class="headerlink" title="SrtingBuilder类"></a>SrtingBuilder类</h4><ul>
<li>基本和StringBuffer类一样</li>
<li>不是线程安全的，方法没有synchronized修饰（没有做互斥处理），是线程不安全的，在单线程下使用</li>
<li>效率是最高的</li>
</ul>
<h4 id="String、StringBuffer、StringBuilder比较"><a href="#String、StringBuffer、StringBuilder比较" class="headerlink" title="String、StringBuffer、StringBuilder比较"></a>String、StringBuffer、StringBuilder比较</h4><ul>
<li><strong>String：不可变字符序列，效率低，但是复用率高</strong></li>
<li><strong>StringBuffer：可变字符序列，效率高，线程安全</strong></li>
<li><strong>StringBuilder：可变字符序列，效率最高，线程不安全</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220403171800848.png" alt="image-20220403171800848"></p>
<ul>
<li>StringVsStringBufferVsStringBuilder.java 效率 ： StringBuilder &gt; StringBuffer &gt; String</li>
</ul>
<h4 id="使用原则"><a href="#使用原则" class="headerlink" title="使用原则"></a>使用原则</h4><ul>
<li>如果字符串存在<strong>大量修改</strong>，一般使用<strong>StringBuilder</strong>或 <strong>StringBuffer</strong></li>
<li>如果字符串存在<strong>大量修改，并且单线程</strong>，使用<strong>StringBuilder</strong></li>
<li>如果字符串存在<strong>大量修改，并且多线程</strong>，使用<strong>StringBuffer</strong></li>
<li>如果字符串<strong>很少修改，被多个对象引用</strong>，使用<strong>String</strong>，如配置信息等</li>
</ul>
<h3 id="Math类方法"><a href="#Math类方法" class="headerlink" title="Math类方法"></a>Math类方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>abs 绝对值</span><br><span class="line"><span class="number">2.</span>pow 求幂</span><br><span class="line"><span class="number">3.</span>ceil 向上取整,返回&gt;=该参数的最小整数(转成 <span class="type">double</span>)</span><br><span class="line"><span class="number">4.</span>floor 向下取整，返回&lt;=该参数的最大整数(转成 <span class="type">double</span>)</span><br><span class="line"><span class="number">5.</span>round 四舍五入 Math.floor(该参数+<span class="number">0.5</span>)</span><br><span class="line"><span class="number">6.</span>sqrt 求开方</span><br><span class="line"><span class="number">7.</span>random 求随机数</span><br><span class="line">a ~ b之间的随机数：a + Math.random() * (b - a)</span><br><span class="line">整数：(<span class="type">int</span>)(a + Math.random() * (b-a +<span class="number">1</span>))     </span><br></pre></td></tr></table></figure>

<h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><ul>
<li><p>Arrays.toString(arr);&#x2F;&#x2F;遍历数组</p>
</li>
<li><p>Arrays.sort(arr);&#x2F;&#x2F;快速排序</p>
</li>
<li><p><strong>定制排序</strong></p>
</li>
<li><pre><code class="java">Arrays.sort(arr, new Comparator&lt;Integer&gt;()&#123;
            @Override
            public int compare(Integer i1, Integer i2) &#123;
                return i2 - i1;
            &#125;
        &#125;);//充分体现了 接口编程 + 动态绑定 + 匿名内部类的综合使用
</code></pre>
</li>
<li><p><strong>Arrays.binarySearch(arr, 567);</strong></p>
<ul>
<li>二分查找，必须有序</li>
<li>如果数组中不存在该元素，就返回 return -(low + 1);</li>
</ul>
</li>
<li><p><strong>copyOf</strong> 数组元素的复制</p>
<ul>
<li>从 arr 数组中，拷贝 arr.length 个元素到 newArr 数组中</li>
<li>如果拷贝的长度 &gt; arr.length 就在新数组的后面 增</li>
<li>如果拷贝长度 &lt; 0 就抛出异常 NegativeArraySizeException</li>
<li>该方法的底层使用的是 System.arraycopy()</li>
</ul>
</li>
<li><p><strong>ill</strong> 数组元素的填充</p>
<ul>
<li>可以理解成是替换原理的元素</li>
</ul>
</li>
<li><p><strong>asList</strong> 将一组值，转换成 list</p>
<ul>
<li>asList 方法，会将 (2,3,4,5,6,1)数据转成一个 List 集合</li>
<li>返回的 asList 编译类型 List（接口）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">asList 运行类型 java.util.Arrays#ArrayList, 是 Arrays 类的</span><br><span class="line"><span class="comment">// 静态内部类 private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable</span></span><br><span class="line"><span class="type">List</span> <span class="variable">asList</span> <span class="operator">=</span> Arrays.asList(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><ul>
<li><p>exit(0) 表示程序退出</p>
</li>
<li><p>arraycopy ：复制数组元素，比较适合底层调用， &#x2F;&#x2F; 一般使用 Arrays.copyOf完成复制数组</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// * @param src the source array. // srcPos： 从源数组的哪个索引位置开始拷贝</span></span><br><span class="line"><span class="comment">// * @param srcPos starting position in the source array. // dest : 目标数组，即把源数组的数据拷贝到哪个数组</span></span><br><span class="line"><span class="comment">// * @param dest the destination array. // destPos: 把源数组的数据拷贝到 目标数组的哪个索引</span></span><br><span class="line"><span class="comment">// * @param destPos starting position in the destination data. // length: 从源数组拷贝多少个数据到目标数组</span></span><br><span class="line"><span class="comment">// * @param length the number of array elements to be copied. System.arraycopy(src, 0, dest, 0, src.length);</span></span><br></pre></td></tr></table></figure>

<ul>
<li>currentTimeMillens:返回当前时间距离 1970-1-1 的毫秒数</li>
</ul>
<h3 id="BigIteger（大正数）和BigDecimal类（大分数）"><a href="#BigIteger（大正数）和BigDecimal类（大分数）" class="headerlink" title="BigIteger（大正数）和BigDecimal类（大分数）"></a>BigIteger（大正数）和BigDecimal类（大分数）</h3><ul>
<li>add 加</li>
<li>subtract 减</li>
<li>multiply 乘</li>
<li>divide 除</li>
<li>调用divide方法时，指定精度<code>bigDecimal.divide(bigDecimal2, BigDecimal.ROUND_CEILING))</code></li>
</ul>
<h3 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h3><h4 id="Date：第一代日期类"><a href="#Date：第一代日期类" class="headerlink" title="Date：第一代日期类"></a>Date：第一代日期类</h4><ul>
<li>精确到毫秒，代表特定的瞬间</li>
<li>SimpleDateFormat：格式和解析日期的类，允许进行格式化（日期-&gt;文本）、解析（文本-&gt;日期）和规范化</li>
<li>获取当前系统时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">//获取当前系统时间</span></span><br><span class="line">System.out.println(<span class="string">&quot;当前日期=&quot;</span> + d1);</span><br><span class="line"><span class="type">Date</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">9234567</span>); <span class="comment">//通过指定毫秒数得到时间</span></span><br><span class="line">System.out.println(<span class="string">&quot;d2=&quot;</span> + d2); <span class="comment">//获取某个时间对应的毫秒数</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这里的 Date 类是在 java.util 包</li>
<li>默认输出的日期格式是国外的方式, 因此通常需要对格式进行转换</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy 年 MM 月 dd 日 hh:mm:ss E&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> sdf.format(d1); <span class="comment">// format:将日期转换成指定格式的字符串</span></span><br><span class="line">System.out.println(<span class="string">&quot;当前日期=&quot;</span> + format);</span><br></pre></td></tr></table></figure>

<ul>
<li>创建 SimpleDateFormat 对象，可以指定相应的格式</li>
<li>这里的格式使用的字母是规定好，不能乱写</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;1996 年 01 月 01 日 10:20:30 星期一&quot;</span>;</span><br><span class="line"><span class="type">Date</span> <span class="variable">parse</span> <span class="operator">=</span> sdf.parse(s);</span><br><span class="line">System.out.println(<span class="string">&quot;parse=&quot;</span> + sdf.format(parse));</span><br></pre></td></tr></table></figure>

<ul>
<li>可以把一个格式化的 String 转成对应的 Date</li>
<li>得到 Date 仍然在输出时，还是按照国外的形式，如果希望指定格式输出，需要转换</li>
<li>在把 String -&gt; Date ， 使用的 sdf 格式需要和你给的 String 的格式一样，否则会抛出转换异常</li>
</ul>
<h4 id="Calendar：第二代日期类"><a href="#Calendar：第二代日期类" class="headerlink" title="Calendar：第二代日期类"></a>Calendar：第二代日期类</h4><ul>
<li>Calendar 是一个抽象类， 并且构造器是 private</li>
<li>可以通过 getInstance() 来获取实例</li>
<li>Calendar 没有提供对应的格式化的类，因此需要程序员自己组合来输出(灵活)</li>
<li>如果我们需要按照 24 小时进制来获取时间， Calendar.HOUR &#x3D;&#x3D;改成&#x3D;&gt; Calendar.HOUR_OF_DAY Calendar c &#x3D; Calendar.getInstance(); &#x2F;&#x2F;创建日历类对象&#x2F;&#x2F;比较简单，自由</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.获取日历对象的某个日历字段</span><br><span class="line">System.out.println(<span class="string">&quot;年：&quot;</span> + c.get(Calendar.YEAR));</span><br><span class="line"><span class="comment">// 这里为什么要 + 1, 因为 Calendar 返回月时候，是按照 0 开始编号</span></span><br><span class="line">System.out.println(<span class="string">&quot;月：&quot;</span> + (c.get(Calendar.MONTH) + <span class="number">1</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;日：&quot;</span> + c.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">System.out.println(<span class="string">&quot;小时：&quot;</span> + c.get(Calendar.HOUR));</span><br><span class="line">System.out.println(<span class="string">&quot;分钟：&quot;</span> + c.get(Calendar.MINUTE));</span><br><span class="line">System.out.println(<span class="string">&quot;秒：&quot;</span> + c.get(Calendar.SECOND));</span><br></pre></td></tr></table></figure>

<h4 id="LocalDate、LocalTime、LocalDateTime-第三代日期类"><a href="#LocalDate、LocalTime、LocalDateTime-第三代日期类" class="headerlink" title="LocalDate、LocalTime、LocalDateTime:第三代日期类"></a>LocalDate、LocalTime、LocalDateTime:第三代日期类</h4><ul>
<li>LocalDate：只包含日期</li>
<li>LocalTime：只包含时间</li>
<li>LocalDateTime：包含日期+时间，可以获取日期和时间字段</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 使用 now() 返回表示当前日期时间的 对象</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now(); <span class="comment">//LocalDate.now();//LocalTime.now()</span></span><br><span class="line">System.out.println(ldt);</span><br><span class="line"><span class="comment">//2. 使用 DateTimeFormatter 对象来进行格式化</span></span><br><span class="line"><span class="comment">// 创建 DateTimeFormatter 对象</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> dateTimeFormatter.format(ldt);</span><br><span class="line">System.out.println(<span class="string">&quot;格式化的日期=&quot;</span> + format);</span><br><span class="line">System.out.println(<span class="string">&quot;年=&quot;</span> + ldt.getYear());</span><br><span class="line">System.out.println(<span class="string">&quot;月=&quot;</span> + ldt.getMonth());</span><br><span class="line">System.out.println(<span class="string">&quot;月=&quot;</span> + ldt.getMonthValue());</span><br><span class="line">System.out.println(<span class="string">&quot;日=&quot;</span> + ldt.getDayOfMonth());</span><br><span class="line">System.out.println(<span class="string">&quot;时=&quot;</span> + ldt.getHour());</span><br><span class="line">System.out.println(<span class="string">&quot;分=&quot;</span> + ldt.getMinute());</span><br><span class="line">System.out.println(<span class="string">&quot;秒=&quot;</span> + ldt.getSecond());</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">now</span> <span class="operator">=</span> LocalDate.now(); <span class="comment">//可以获取年月日</span></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">now2</span> <span class="operator">=</span> LocalTime.now();<span class="comment">//获取到时分秒</span></span><br><span class="line"><span class="comment">//提供 plus 和 minus 方法可以对当前时间进行加或者减</span></span><br><span class="line"><span class="comment">//看看 890 天后，是什么时候 把 年月日-时分秒</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> ldt.plusDays(<span class="number">890</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;890 天后=&quot;</span> + dateTimeFormatter.format(localDateTime));</span><br><span class="line"><span class="comment">//看看在 3456 分钟前是什么时候，把 年月日-时分秒输出</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime2</span> <span class="operator">=</span> ldt.minusMinutes(<span class="number">3456</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;3456 分钟前 日期=&quot;</span> + dateTimeFormatter.format(localDateTime2));</span><br></pre></td></tr></table></figure>

<h4 id="DateTimeFormatter格式日期类"><a href="#DateTimeFormatter格式日期类" class="headerlink" title="DateTimeFormatter格式日期类"></a>DateTimeFormatter格式日期类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH小时mm分钟ss秒&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">strDate</span> <span class="operator">=</span> dtf.format(ldf);</span><br></pre></td></tr></table></figure>

<h4 id="Instant时间戳"><a href="#Instant时间戳" class="headerlink" title="Instant时间戳"></a>Instant时间戳</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.通过 静态方法 now() 获取表示当前时间戳的对象</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">now</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">System.out.println(now);</span><br><span class="line"><span class="comment">//2. 通过 from 可以把 Instant 转成 Date</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> Date.from(now);</span><br><span class="line"><span class="comment">//3. 通过 date 的 toInstant() 可以把 date 转成 Instant 对象</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> date.toInstant();</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220403231955449.png" alt="image-20220403231955449"></p>
<h4 id="更多方法"><a href="#更多方法" class="headerlink" title="更多方法"></a>更多方法</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220403232032071.png" alt="image-20220403232032071"></p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul>
<li><p>数组</p>
<ul>
<li>长度必须开始时指定。而且一旦指定，不能修改</li>
<li>保存的必须为同一类型的元素</li>
<li>使用数组进行增加&#x2F;删除元素比较麻烦</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person[] pers = <span class="keyword">new</span> <span class="title class_">Person</span>[<span class="number">1</span>];</span><br><span class="line">per[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">Person[] pers2 = <span class="keyword">new</span> <span class="title class_">Person</span>[per.length.length + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>()&#123;&#125;<span class="comment">//拷贝pers数组的元素到pers2</span></span><br><span class="line">pers2[pers2.length - <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Person</span>();<span class="comment">//添加新对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以动态保存任意多个对象，使用方便</p>
</li>
<li><p>提供了一系列方便的操作对象的方法：add、remove、ste、get等</p>
</li>
<li><p>使用集合添加、删除新元素的代码简洁了</p>
</li>
</ul>
<h4 id="集合的框架体系"><a href="#集合的框架体系" class="headerlink" title="集合的框架体系"></a>集合的框架体系</h4><ul>
<li>Java的集合类很多，主要分为两大类：单列集合(Collection)、双列集合（Map-存放的K-V）</li>
<li>框架体系图</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220403233008504.png" alt="image-20220403233008504"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220403233020839.png" alt="image-20220403233020839"></p>
<h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><ul>
<li>Collection实现子类可以存放多个元素，每个元素可以是Object</li>
<li>有些Collection的实现类，可以存放重复元素，有些不可以</li>
<li>有些Collection的实现类，有些是有序的（List）、有些不是有序的（Set）</li>
<li>Collection接口没有直接的实现子类，是通过它的子接口Set和List实现的</li>
</ul>
<h4 id="Collection接口的常用方法"><a href="#Collection接口的常用方法" class="headerlink" title="Collection接口的常用方法"></a>Collection接口的常用方法</h4><ul>
<li><strong>add</strong>:添加单个元素</li>
<li><strong>remove</strong>:删除指定元素<ul>
<li>可以下标</li>
<li>可以指定元素</li>
</ul>
</li>
<li><strong>contains</strong>:查找元素是否存在</li>
<li><strong>size</strong>:获取元素个数</li>
<li><strong>isEmpty</strong>:判断是否为空</li>
<li><strong>clea</strong>r:清空</li>
<li><strong>addAll</strong>:添加多个元素</li>
<li><strong>containsAll</strong>:查找多个元素是否都存在</li>
<li><strong>removeAll</strong>：删除多个元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">// add:添加单个元素</span></span><br><span class="line">list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">list.add(<span class="number">10</span>);<span class="comment">//list.add(new Integer(10))</span></span><br><span class="line">list.add(<span class="literal">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">// remove:删除指定元素</span></span><br><span class="line"><span class="comment">//list.remove(0);//删除第一个元素</span></span><br><span class="line">list.remove(<span class="literal">true</span>);<span class="comment">//指定删除某个元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">// contains:查找元素是否存在</span></span><br><span class="line">System.out.println(list.contains(<span class="string">&quot;jack&quot;</span>));<span class="comment">//T</span></span><br><span class="line"><span class="comment">// size:获取元素个数</span></span><br><span class="line">System.out.println(list.size());<span class="comment">//2</span></span><br><span class="line"><span class="comment">// isEmpty:判断是否为空</span></span><br><span class="line">System.out.println(list.isEmpty());<span class="comment">//F</span></span><br><span class="line"><span class="comment">// clear:清空</span></span><br><span class="line">list.clear();</span><br><span class="line">System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">// addAll:添加多个元素</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list2.add(<span class="string">&quot;红楼梦&quot;</span>);</span><br><span class="line">list2.add(<span class="string">&quot;三国演义&quot;</span>);</span><br><span class="line">list.addAll(list2);</span><br><span class="line">System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line"><span class="comment">// containsAll:查找多个元素是否都存在</span></span><br><span class="line">System.out.println(list.containsAll(list2));<span class="comment">//T</span></span><br><span class="line"><span class="comment">// removeAll：删除多个元素</span></span><br><span class="line">list.add(<span class="string">&quot;聊斋&quot;</span>);</span><br><span class="line">list.removeAll(list2);</span><br><span class="line">System.out.println(<span class="string">&quot;list=&quot;</span> + list);<span class="comment">//[聊斋]</span></span><br><span class="line"><span class="comment">// 说明：以 ArrayList 实现类来演示</span></span><br></pre></td></tr></table></figure>

<h4 id="Collection接口遍历元素方式"><a href="#Collection接口遍历元素方式" class="headerlink" title="Collection接口遍历元素方式"></a>Collection接口遍历元素方式</h4><ul>
<li>使用<strong>Iterator（迭代器）</strong></li>
</ul>
<h4 id="Iterator（迭代器）"><a href="#Iterator（迭代器）" class="headerlink" title="Iterator（迭代器）"></a>Iterator（迭代器）</h4><ul>
<li>Iterator对象称为迭代器，主要用于便利Collection集合中的元素</li>
<li>所有实现Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，即可以返回一个迭代器</li>
<li><strong>Iterator仅用于遍历集合，Iterator本身并不存放对象</strong></li>
</ul>
<h5 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();<span class="comment">//得到一个迭代器</span></span><br><span class="line"><span class="comment">//hasNext():判断是否还有下一个元素</span></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">	<span class="comment">//next()作用：1、下移 2、将下移以后的集合位置上的元素返回</span></span><br><span class="line">	System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="接口方法"><a href="#接口方法" class="headerlink" title="接口方法"></a>接口方法</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220403235217681.png" alt="image-20220403235217681"></p>
<ul>
<li><strong>调用iterator.next()方法前必须先调用iterator.hasNext()进行检测</strong>。若不调用且下一条记录无效，直接调用会抛出<strong>NoSuchElementException异常</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionIterator</span> &#123;</span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">col</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;三国演义&quot;</span>, <span class="string">&quot;罗贯中&quot;</span>, <span class="number">10.1</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;小李飞刀&quot;</span>, <span class="string">&quot;古龙&quot;</span>, <span class="number">5.1</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;红楼梦&quot;</span>, <span class="string">&quot;曹雪芹&quot;</span>, <span class="number">34.6</span>));</span><br><span class="line">        <span class="comment">//System.out.println(&quot;col=&quot; + col);</span></span><br><span class="line">        <span class="comment">//现在老师希望能够遍历 col 集合</span></span><br><span class="line">        <span class="comment">//1. 先得到 col 对应的 迭代器</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> col.iterator();</span><br><span class="line">        <span class="comment">//2. 使用 while 循环遍历</span></span><br><span class="line">        <span class="comment">// while (iterator.hasNext()) &#123;//判断是否还有数据</span></span><br><span class="line">        <span class="comment">// //返回下一个元素，类型是 Object</span></span><br><span class="line">        <span class="comment">// Object obj = iterator.next();</span></span><br><span class="line">        <span class="comment">// System.out.println(&quot;obj=&quot; + obj);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">//老师教大家一个快捷键，快速生成 while =&gt; itit</span></span><br><span class="line">        <span class="comment">//显示所有的快捷键的的快捷键 ctrl + j</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj=&quot;</span> + obj)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 当退出 while 循环后 , 这时 iterator 迭代器，指向最后的元素</span></span><br><span class="line">        <span class="comment">// iterator.next();//NoSuchElementException</span></span><br><span class="line">        <span class="comment">//4. 如果希望再次遍历，需要重置我们的迭代器</span></span><br><span class="line">        iterator = col.iterator();</span><br><span class="line">        System.out.println(<span class="string">&quot;===第二次遍历===&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj=&quot;</span> + obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(String name, String author, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">    	<span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAuthor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> author;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuthor</span><span class="params">(String author)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Book&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;, author=&#x27;&quot;</span> + author + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h4><ul>
<li>特点：是简化版的iterator，本质一样，只能用于遍历集合和数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object object : col)&#123;</span><br><span class="line">	System.out.println(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h3><ul>
<li>元素有序（添加顺序和取出顺序一致）、且可以重复</li>
<li>支持索引</li>
<li>元素都对应一个整数型的序号记载在容器中的位置，可以根据序号存取容器中的元素</li>
<li>常用的有：ArrayList、LinkedList、Vector</li>
</ul>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li><strong>void add</strong>(int index, Object ele):在 index 位置插入 ele 元素</li>
<li><strong>boolean addAll</strong>(int index, Collection eles):从 index 位置开始将 eles 中的所有元素添加进来</li>
<li><strong>Object get(int index)</strong>:获取指定 index 位置的元素</li>
<li><strong>int indexOf(Object obj)</strong>:返回 obj 在集合中首次出现的位置</li>
<li><strong>int lastIndexOf(Object obj)</strong>:返回 obj 在当前集合中末次出现的位置</li>
<li><strong>Object remove(int index)</strong>:移除指定 index 位置的元素，并返回此元素</li>
<li><strong>Object set(int index, Object ele)</strong>:设置指定 index 位置的元素为 ele , 相当于是替换.</li>
<li><strong>List subList(int fromIndex, int toIndex)</strong>:返回从 fromIndex 到 toIndex 位置的子集合<ul>
<li>fromIndex &lt;&#x3D; subList &lt; toIndex</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListMethod</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;贾宝玉&quot;</span>);</span><br><span class="line">    <span class="comment">// void add(int index, Object ele):在 index 位置插入 ele 元素</span></span><br><span class="line">    <span class="comment">//在 index = 1 的位置插入一个对象</span></span><br><span class="line">    list.add(<span class="number">1</span>, <span class="string">&quot;韩顺平&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line">    <span class="comment">// boolean addAll(int index, Collection eles):从 index 位置开始将 eles 中的所有元素添加进来</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    list2.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    list2.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    list.addAll(<span class="number">1</span>, list2);</span><br><span class="line">    System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line">    <span class="comment">// Object get(int index):获取指定 index 位置的元素</span></span><br><span class="line">    <span class="comment">//说过</span></span><br><span class="line">    <span class="comment">// int indexOf(Object obj):返回 obj 在集合中首次出现的位置</span></span><br><span class="line">    System.out.println(list.indexOf(<span class="string">&quot;tom&quot;</span>));<span class="comment">//2</span></span><br><span class="line">    <span class="comment">// int lastIndexOf(Object obj):返回 obj 在当前集合中末次出现的位置</span></span><br><span class="line">    list.add(<span class="string">&quot;韩顺平&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line">    System.out.println(list.lastIndexOf(<span class="string">&quot;韩顺平&quot;</span>));</span><br><span class="line">    <span class="comment">// Object remove(int index):移除指定 index 位置的元素，并返回此元素</span></span><br><span class="line">    list.remove(<span class="number">0</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line">    <span class="comment">// Object set(int index, Object ele):设置指定 index 位置的元素为 ele , 相当于是替换. list.set(1, &quot;玛丽&quot;);</span></span><br><span class="line">    System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line">    <span class="comment">// List subList(int fromIndex, int toIndex):返回从 fromIndex 到 toIndex 位置的子集合</span></span><br><span class="line">    <span class="comment">// 注意返回的子集合 fromIndex &lt;= subList &lt; toIndex</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">returnlist</span> <span class="operator">=</span> list.subList(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;returnlist=&quot;</span> + returnlist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>三种遍历方法：<ul>
<li>使用iteratoor</li>
<li>使用增强for</li>
<li>使用普通for</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;鱼香肉丝&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;北京烤鸭子&quot;</span>);</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="comment">//1. 迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;=====增强 for=====&quot;</span>);</span><br><span class="line"><span class="comment">//2. 增强 for</span></span><br><span class="line"><span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;o=&quot;</span> + o);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;=====普通 for====&quot;</span>);</span><br><span class="line"><span class="comment">//3. 使用普通 for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;对象=&quot;</span> + list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用LinkedList完成使用方式和ArrayList一样</li>
</ul>
<h4 id="ArrayList底层结构和原码分析"><a href="#ArrayList底层结构和原码分析" class="headerlink" title="ArrayList底层结构和原码分析"></a>ArrayList底层结构和原码分析</h4><ul>
<li><strong>可以加入null，且可以加入多个</strong></li>
<li>由数组实现数据储存</li>
<li>基本等同于Vector，除了<strong>是线程不安全的</strong>，多线程下不建议使用</li>
<li>维护了一个Object数组elementData.transient Object elementData;&#x2F;&#x2F;<strong>transient</strong>表示瞬间，短暂的，表示该属性不会被<strong>序列化</strong></li>
<li>当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第一次添加，则扩容为10，如需再次扩容，则扩容为elementData为1.5倍（elementData.length + elementData &#x2F; 2）;</li>
<li>如果使用的是指定大小的构造器，则初始容量为指定大小，后续扩容同上</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220404131337543.png" alt="image-20220404131337543"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220404131355602.png" alt="image-20220404131355602"></p>
<h4 id="Vector底层结构和原码剖析"><a href="#Vector底层结构和原码剖析" class="headerlink" title="Vector底层结构和原码剖析"></a>Vector底层结构和原码剖析</h4><ul>
<li>底层也是一个对象数组，protected Object[] elementData;</li>
<li>是线程同步的，即线程安全的，方法都带有<strong>syncharonized</strong></li>
<li>需要线程同步安全时，考虑使用Vector</li>
</ul>
<h4 id="ArrayList和Vector区别"><a href="#ArrayList和Vector区别" class="headerlink" title="ArrayList和Vector区别"></a>ArrayList和Vector区别</h4><table>
<thead>
<tr>
<th></th>
<th>底层结构</th>
<th>版本</th>
<th>线程同步效率</th>
<th>扩容倍数</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>可变数组Object[]</td>
<td>jdk1.2</td>
<td>不安全，效率高</td>
<td>默认10，按1.5倍扩容</td>
</tr>
<tr>
<td>Vector</td>
<td>可变数组Object[]</td>
<td>jdk1.0</td>
<td>安全，效率不高</td>
<td>默认10，按2.0倍扩容</td>
</tr>
</tbody></table>
<h3 id="LinkedList底层结构"><a href="#LinkedList底层结构" class="headerlink" title="LinkedList底层结构"></a>LinkedList底层结构</h3><ul>
<li>实现了<strong>双向链表</strong>和<strong>双端队列</strong>特点</li>
<li><strong>可以添加任意元素（可以重复），包括null</strong></li>
<li><strong>线程不安全</strong>，没有实现同步</li>
</ul>
<h4 id="底层操作机制"><a href="#底层操作机制" class="headerlink" title="底层操作机制"></a>底层操作机制</h4><ul>
<li>维护了两个属性first和last分别指向<strong>首节点</strong>和<strong>尾节点</strong></li>
<li>每个节点（Node对象），里面又维护了<strong>prev</strong>、<strong>next</strong>、<strong>item</strong>三个属性</li>
<li>prev指向前一个，next指向后一个</li>
<li>元素的添加和删除，不是通过数组完成的，相对来说效率较高</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220404132406569.png" alt="image-20220404132406569"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//模拟一个简单的双向链表</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">jack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">tom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">hsp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;老韩&quot;</span>);</span><br><span class="line">    <span class="comment">//连接三个结点，形成双向链表</span></span><br><span class="line">    <span class="comment">//jack -&gt; tom -&gt; hsp</span></span><br><span class="line">    jack.next = tom;</span><br><span class="line">    tom.next = hsp;</span><br><span class="line">    <span class="comment">//hsp -&gt; tom -&gt; jack</span></span><br><span class="line">    hsp.pre = tom;</span><br><span class="line">    tom.pre = jack;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> jack;<span class="comment">//让 first 引用指向 jack,就是双向链表的头结点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> hsp; <span class="comment">//让 last 引用指向 hsp,就是双向链表的尾结点</span></span><br><span class="line">    <span class="comment">//演示，从头到尾进行遍历</span></span><br><span class="line">    System.out.println(<span class="string">&quot;===从头到尾进行遍历===&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(first == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出 first 信息</span></span><br><span class="line">        System.out.println(first);</span><br><span class="line">        first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//演示，从尾到头的遍历</span></span><br><span class="line">    System.out.println(<span class="string">&quot;====从尾到头的遍历====&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(last == <span class="literal">null</span>) &#123;</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出 last 信息</span></span><br><span class="line">        System.out.println(last);</span><br><span class="line">        last = last.pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//演示链表的添加对象/数据，是多么的方便</span></span><br><span class="line">    <span class="comment">//要求，是在 tom --------- 老韩直接，插入一个对象 smith</span></span><br><span class="line">    <span class="comment">//1. 先创建一个 Node 结点，name 就是 smith</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">smith</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;smith&quot;</span>);</span><br><span class="line">    <span class="comment">//下面就把 smith 加入到双向链表了</span></span><br><span class="line">    smith.next = hsp;</span><br><span class="line">    smith.pre = tom;</span><br><span class="line">    hsp.pre = smith;</span><br><span class="line">    tom.next = smith;</span><br><span class="line">    <span class="comment">//让 first 再次指向 jack</span></span><br><span class="line">    first = jack;<span class="comment">//让 first 引用指向 jack,就是双向链表的头结点</span></span><br><span class="line">    System.out.println(<span class="string">&quot;===从头到尾进行遍历===&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(first == <span class="literal">null</span>) &#123;</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出 first 信息</span></span><br><span class="line">        System.out.println(first);</span><br><span class="line">        first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    last = hsp; <span class="comment">//让 last 重新指向最后一个结点</span></span><br><span class="line">    <span class="comment">//演示，从尾到头的遍历</span></span><br><span class="line">    System.out.println(<span class="string">&quot;====从尾到头的遍历====&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(last == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出 last 信息</span></span><br><span class="line">        System.out.println(last);</span><br><span class="line">        last = last.pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个 Node 类，Node 对象 表示双向链表的一个结点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object item; <span class="comment">//真正存放数据</span></span><br><span class="line">    <span class="keyword">public</span> Node next; <span class="comment">//指向后一个结点</span></span><br><span class="line">    <span class="keyword">public</span> Node pre; <span class="comment">//指向前一个结点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Object name)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.item = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&quot;Node name=&quot;</span> + item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li><strong>linkedList.remove()</strong>; &#x2F;&#x2F; 这里默认删除的是第一个结点</li>
<li><strong>linkedList.set(1, 999)</strong>;&#x2F;&#x2F;修改某个结点对象 </li>
<li><strong>linkedList.get(1)</strong>: 是得到双向链表的第二个对象</li>
</ul>
<h4 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a>ArrayList和LinkedList区别</h4><table>
<thead>
<tr>
<th></th>
<th>底层结构</th>
<th>增删效率</th>
<th>改查效率</th>
</tr>
</thead>
<tbody><tr>
<td>ArratList</td>
<td>可变数组</td>
<td>较低，数组扩容</td>
<td>较高</td>
</tr>
<tr>
<td>LinkedList</td>
<td>双向链表</td>
<td>较高，通过链表追加</td>
<td>较低</td>
</tr>
</tbody></table>
<ul>
<li><strong>改查较多</strong>，使用<strong>ArrayList</strong></li>
<li><strong>增删较多</strong>，使用<strong>LinkedList</strong></li>
<li>一般来说，在程序中<strong>大部分都是查询</strong>，因此会选择<strong>ArratList</strong></li>
<li>根据业务灵活选用</li>
</ul>
<h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><ul>
<li>无序</li>
<li>不允许重复</li>
<li>常用接口有<strong>HashSet</strong>和<strong>TreeSet</strong></li>
</ul>
<h4 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li>Set是Collection的子接口，常用方法跟Collection接口一样</li>
</ul>
<h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><ul>
<li>使用迭代器</li>
<li>增强for</li>
<li>不能使用索引</li>
</ul>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><ul>
<li>实现了Set接口</li>
<li>实际上是HashMap</li>
<li><strong>可以存放null，只有一个</strong></li>
<li>HashSet<strong>不保证元素有序</strong>，取决于hash后，在确定索引的结果</li>
<li><strong>不能有重复元素</strong></li>
</ul>
<h3 id="HashSet添加元素底层实现"><a href="#HashSet添加元素底层实现" class="headerlink" title="HashSet添加元素底层实现"></a>HashSet添加元素底层实现</h3><ul>
<li>底层是HashMap</li>
<li>添加一个元素时会先得到hash值，然后转换成索引值</li>
<li>找到储存数据表table（一个数组），看这个索引位置是否已经存放有元素</li>
<li>如果没有，直接添加</li>
<li>如果有，调用<strong>equals</strong>进行比较，如果相同，则放弃添加，如果不同，则添加到最后</li>
<li>在java8中，如果一条链表的元素个数达到TREEIFY_THRESHOLD（默认是8），并且table大小&gt;&#x3D; MIN TREEIFY CAPACITY（默认是64），就会进行树化（红黑树）</li>
<li><strong>追一次源码</strong><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1fh411y7R8?p=521">HahsSet底层添加元素机制</a></li>
</ul>
<h3 id="HashSet的扩容和转成红黑树机制"><a href="#HashSet的扩容和转成红黑树机制" class="headerlink" title="HashSet的扩容和转成红黑树机制"></a>HashSet的扩容和转成红黑树机制</h3><ul>
<li>HashSet底层是HashMap，第一次添加时，table数组扩容到16，临界值（threshold）时16*加载因子（loadFactor）是0.75 &#x3D; 12</li>
<li>如果table数组使用到了临界值12，就会扩容到16 * 2 &#x3D; 32，新的临界值就是32 * 0.75 &#x3D; 24，以此类推</li>
<li>在java8中，如果一条链表的元素个数达到TREEIFY_THRESHOLD（默认是8），并且table大小&gt;&#x3D; MIN TREEIFY CAPACITY（默认是64），就会进行树化（红黑树），<strong>否则仍然采用数组扩容机制</strong>（一直扩到64为止）</li>
<li><strong>追源码<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1fh411y7R8?p=521">HahsSet底层添加元素机制</a></strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果当前索引位置对应的链表的第一个元素和准备添加的 key 的 hash 值一样</span></span><br><span class="line"><span class="comment">//并且满足 下面两个条件之一:</span></span><br><span class="line"><span class="comment">//(1) 准备加入的 key 和 p 指向的 Node 结点的 key 是同一个对象</span></span><br><span class="line"><span class="comment">//(2) p 指向的 Node 结点的 key 的 equals() 和准备加入的 key 比较后相同</span></span><br><span class="line"><span class="comment">//就不能加入</span></span><br></pre></td></tr></table></figure>

<h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><ul>
<li>是HashSet的子类</li>
<li>底层是一个LinkedHashMap，维护了一个<strong>数组+双向链表</strong></li>
<li>根据元素的hashCode值来决定元素的储存位置，同时使用链表维护元素的次序，这使得元素<strong>看起来是以插入顺序保存的</strong></li>
<li><strong>不允许添加重复元素</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220416122624021.png" alt="image-20220416122624021"></p>
<h2 id="Map接口（JDK8的特点）"><a href="#Map接口（JDK8的特点）" class="headerlink" title="Map接口（JDK8的特点）"></a>Map接口（JDK8的特点）</h2><ul>
<li>Map与Collection并列存在，用于保存具有映射关系的数据：Key-Value</li>
<li>Map中的 key 和 value 可以是任何引用类型的数据，会封装到HashMap$Node对象中</li>
<li>Map中的 key 不允许重复，原因和HashSet一样</li>
<li>Map中的 value 可以重复</li>
<li><strong>常用String类作为Map的 key （不一定要用）</strong></li>
<li>key 和 value 之间存在单向一对一关系，可以通过key访问value</li>
<li>常用实现类：<strong>HashMap</strong>、<strong>Hashtable</strong>和<strong>Properties</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;no1&quot;</span>, <span class="string">&quot;韩顺平&quot;</span>);<span class="comment">//k-v</span></span><br><span class="line">map.put(<span class="string">&quot;no2&quot;</span>, <span class="string">&quot;张无忌&quot;</span>);<span class="comment">//k-v</span></span><br><span class="line">map.put(<span class="string">&quot;no1&quot;</span>, <span class="string">&quot;张三丰&quot;</span>);<span class="comment">//当有相同的 k , 就等价于替换. map.put(&quot;no3&quot;, &quot;张三丰&quot;);//k-v</span></span><br><span class="line">map.put(<span class="literal">null</span>, <span class="literal">null</span>); <span class="comment">//k-v</span></span><br><span class="line">map.put(<span class="literal">null</span>, <span class="string">&quot;abc&quot;</span>); <span class="comment">//等价替换</span></span><br><span class="line">map.put(<span class="string">&quot;no4&quot;</span>, <span class="literal">null</span>); <span class="comment">//k-v</span></span><br><span class="line">map.put(<span class="string">&quot;no5&quot;</span>, <span class="literal">null</span>); <span class="comment">//k-v</span></span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;赵敏&quot;</span>);<span class="comment">//k-v</span></span><br><span class="line">map.put(<span class="keyword">new</span> <span class="title class_">Object</span>(), <span class="string">&quot;金毛狮王&quot;</span>);<span class="comment">//k-v</span></span><br><span class="line"><span class="comment">// 通过 get 方法，传入 key ,会返回对应的 value</span></span><br><span class="line">System.out.println(map.get(<span class="string">&quot;no2&quot;</span>));<span class="comment">//张无忌</span></span><br><span class="line">System.out.println(<span class="string">&quot;map=&quot;</span> + map);</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220416123231257.png" alt="image-20220416123231257"></p>
<ul>
<li>可以说<strong>一个key - value就是一个Entry</strong></li>
</ul>
<h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><ul>
<li><strong>containsKey</strong>：查找键是否存在</li>
<li><strong>keySet</strong>：获取所有的键</li>
<li><strong>entrySet</strong>：获取所有关系k-v</li>
<li><strong>values</strong>：获取所有的值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一组: 先取出 所有的 Key , 通过 Key 取出对应的 Value</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">keyset</span> <span class="operator">=</span> map.keySet();</span><br><span class="line"><span class="comment">//(1) 增强 for</span></span><br><span class="line">System.out.println(<span class="string">&quot;-----第一种方式-------&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Object key : keyset) &#123;</span><br><span class="line">	System.out.println(key + <span class="string">&quot;-&quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//(2) 迭代器</span></span><br><span class="line">System.out.println(<span class="string">&quot;----第二种方式--------&quot;</span>);</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> keyset.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(key + <span class="string">&quot;-&quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二组: 把所有的 values 取出</span></span><br><span class="line"><span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line"><span class="comment">//这里可以使用所有的 Collections 使用的遍历方法</span></span><br><span class="line"><span class="comment">//(1) 增强 for</span></span><br><span class="line">System.out.println(<span class="string">&quot;---取出所有的 value 增强 for----&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Object value : values) &#123;</span><br><span class="line">	System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//(2) 迭代器</span></span><br><span class="line">System.out.println(<span class="string">&quot;---取出所有的 value 迭代器----&quot;</span>);</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator2</span> <span class="operator">=</span> values.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator2.hasNext()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> iterator2.next();</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三组: 通过 EntrySet 来获取 k-v</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();<span class="comment">// EntrySet&lt;Map.Entry&lt;K,V&gt;&gt;</span></span><br><span class="line"><span class="comment">//(1) 增强 for</span></span><br><span class="line">System.out.println(<span class="string">&quot;----使用 EntrySet 的 for 增强(第 3 种)----&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Object entry : entrySet) &#123;</span><br><span class="line">    <span class="comment">//将 entry 转成 Map.Entry</span></span><br><span class="line">    Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) entry;</span><br><span class="line">    System.out.println(m.getKey() + <span class="string">&quot;-&quot;</span> + m.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//(2) 迭代器</span></span><br><span class="line">System.out.println(<span class="string">&quot;----使用 EntrySet 的 迭代器(第 4 种)----&quot;</span>);</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator3</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator3.hasNext()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">entry</span> <span class="operator">=</span> iterator3.next();</span><br><span class="line">    <span class="comment">//System.out.println(next.getClass());//HashMap$Node -实现-&gt; Map.Entry (getKey,getValue)</span></span><br><span class="line">    <span class="comment">//向下转型 Map.Entry</span></span><br><span class="line">    Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) entry;</span><br><span class="line">    System.out.println(m.getKey() + <span class="string">&quot;-&quot;</span> + m.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ul>
<li>是使用最高的Map实现类</li>
<li>以k-v的形式储存数据（HashMap$Node类型实现了Map.Entry&lt;K,V&gt;）</li>
<li><strong>key不能重复，但值可以重复，允许使用null键和null值</strong></li>
<li>添加相同的key会覆盖原来的k-v，等同于修改</li>
<li>与HashSet一样，不保证映射的顺序，以为底层是以hash表的方式来存储</li>
<li><strong>HashMap底层：</strong><ul>
<li><strong>jdk8：数组 + 链表 + 红黑树</strong></li>
<li><strong>jdk7：数组 + 链表</strong></li>
</ul>
</li>
<li><strong>没有实现同步</strong>，是现成不安全的，方法没有synchronized</li>
</ul>
<h3 id="HashMap底层机制"><a href="#HashMap底层机制" class="headerlink" title="HashMap底层机制"></a>HashMap底层机制</h3><ul>
<li>底层维护了Node类型的数组table，默认为null</li>
<li>当创建对象时，将加载因子（loadfactor）初始化为0.75</li>
<li>当添加k-v时，通过key的哈希值得到在table的索引<ul>
<li>是否有元素，没有就直接加</li>
<li>有就判断key是否相等，相等就直接替换val</li>
<li>不相等就判断是树结构还是链表，做出对应处理</li>
<li>如果容量不够，则扩容</li>
</ul>
</li>
<li>第一次添加，扩容table为16，临界值（threshold）为12（16*0.75）</li>
<li>以后扩容，则扩容为原来的2倍，临界值为原来的2倍</li>
<li>在java8中，如果一条链表元素超过TREEIFY_THRESHOLD(默认是8)，并且他变了的大小 &gt;&#x3D; MIN_TREEIFY_CAPACITY(默认是64)，就会进行树化，不够就扩容到64再树化（红黑树）</li>
</ul>
<h2 id="Hashtable（不能存null）"><a href="#Hashtable（不能存null）" class="headerlink" title="Hashtable（不能存null）"></a>Hashtable（不能存null）</h2><ul>
<li><strong>key和val都不能为null</strong>，否则抛出空指针异常</li>
<li>使用方法基本与HashMap一样</li>
<li>是线程安全的（synchronized）,HashMap是线程不安全的</li>
</ul>
<h3 id="Hashmap-和-Hashtable对比"><a href="#Hashmap-和-Hashtable对比" class="headerlink" title="Hashmap 和 Hashtable对比"></a>Hashmap 和 Hashtable对比</h3><table>
<thead>
<tr>
<th></th>
<th>版本</th>
<th>线程安全（同步）</th>
<th>效率</th>
<th>允许null键和null值</th>
</tr>
</thead>
<tbody><tr>
<td>HashMap</td>
<td>1.2</td>
<td>不安全</td>
<td>高</td>
<td>可以</td>
</tr>
<tr>
<td>Hashtable</td>
<td>1.0</td>
<td>安全</td>
<td>较低</td>
<td>不可以</td>
</tr>
</tbody></table>
<h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><ul>
<li><strong>特点和Hashtable类似</strong></li>
<li>可以用于从 xxx.properties文件中，加载数据到Properties类对象，并进行读取和修改</li>
<li>xxx。properties文件通常作为配置文件</li>
</ul>
<h2 id="开发中如何使用集合实现类"><a href="#开发中如何使用集合实现类" class="headerlink" title="开发中如何使用集合实现类"></a>开发中如何使用集合实现类</h2><ul>
<li><p>先判断储存的类型</p>
<ul>
<li>一组对象【单例】或一组键值对【双例】</li>
</ul>
</li>
<li><p>一组对象【单例】</p>
<ul>
<li><strong>允许重复</strong>：<strong>List</strong><ul>
<li><strong>增删多</strong>：LinkedList【底层维护一个双向链表】</li>
<li><strong>改查多</strong>：ArrayList【底层维护Object类型的可变数组】</li>
</ul>
</li>
<li><strong>不允许重复</strong>：<strong>Set</strong><ul>
<li><strong>无序</strong>：HashSet【底层是HashMap，维护了一个哈希表 即（数组 + 链表 + 红黑树）】</li>
<li><strong>排序</strong>：TreeSet【默认按字典序排列，实现了Comparator接口，可定制排序】</li>
<li><strong>插入和取出顺序一致</strong>：LinkedHashSet【维护 数组 + 链表】</li>
</ul>
</li>
</ul>
</li>
<li><p>一组键值对【双列】：Map</p>
<ul>
<li><strong>键无序</strong>：HashMap【底层是：哈希表 jdk7：数组 + 链表，jdk8：数组 + 链表 +  红黑树】</li>
<li><strong>键排序</strong>：TreeMap【默认按字典序排列，实现了Comparator接口，可定制排序】</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">treeMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((String) o2).compareTo((String) o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>键插入和取出顺序一致</strong>：LinkedHashMap</li>
<li><strong>读取文件</strong>：Properties</li>
</ul>
</li>
</ul>
<h2 id="泛型（generic）"><a href="#泛型（generic）" class="headerlink" title="泛型（generic）"></a>泛型（generic）</h2><h3 id="为什么是泛型"><a href="#为什么是泛型" class="headerlink" title="为什么是泛型"></a>为什么是泛型</h3><ul>
<li>传统方法不能对加入集合中的数据类型进行约束（不安全）</li>
<li>遍历时需要进行类型转换，如果集合中的数据量大，效率不高</li>
</ul>
<h3 id="泛型的好处"><a href="#泛型的好处" class="headerlink" title="泛型的好处"></a>泛型的好处</h3><ul>
<li><strong>编译时</strong>，检查添加元素的类型，提高了安全性</li>
<li>减少了类型转换的次数，提高效率</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不使用泛型</span></span><br><span class="line">Dog -加入-&gt; Object -取出-&gt; Dog <span class="comment">//放入ArrayList先转成Object</span></span><br><span class="line"><span class="comment">//使用泛型</span></span><br><span class="line">Dog -&gt; Dog -&gt; Dog <span class="comment">//放入取出都不用类型转换</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不在提示编译警告</li>
<li>运行时保证不出<code>ClassCastException</code>异常</li>
<li>代码简洁，健壮性更强</li>
<li>作用：可以在类<strong>声明</strong>时通过一个标识表示类中的某个属性，或方法的返回值类型，或者是参数类型</li>
</ul>
<h3 id="泛型的声明"><a href="#泛型的声明" class="headerlink" title="泛型的声明"></a>泛型的声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IUsb</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">class_name</span>&lt;K,T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>K、T、V不代表值，而是<strong>数据类型</strong></li>
<li>人以字母都行，常用T（Type的首字母）</li>
<li>必须是<strong>引用类型</strong>，不能是<strong>基本数据类型</strong></li>
</ul>
<h3 id="自定义泛型"><a href="#自定义泛型" class="headerlink" title="自定义泛型"></a>自定义泛型</h3><h4 id="自定义泛型类"><a href="#自定义泛型类" class="headerlink" title="自定义泛型类"></a>自定义泛型类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 类名&lt;T,R...&gt;&#123;</span><br><span class="line">	成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>普通成员可以使用泛型</li>
<li>使用泛型的数组，不能初始化【不知道数据类型，不知道开多大的空间】</li>
<li>静态方法中不能使用类的泛型</li>
<li>泛型类的类型，<strong>在创建对象时确定</strong>【创建时需要指定】</li>
<li>在创建对象时，没用指定泛型类型，<strong>默认为Object</strong></li>
</ul>
<h4 id="自定义泛型接口"><a href="#自定义泛型接口" class="headerlink" title="自定义泛型接口"></a>自定义泛型接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名&lt;T,R...&gt;&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接口中，静态成员也不能使用泛型</li>
<li>泛型接口的类型，在<strong>继承接口</strong>或者<strong>实现接口</strong>时确定</li>
<li>没有指定类型，默认Object</li>
</ul>
<h4 id="自定义泛型方法"><a href="#自定义泛型方法" class="headerlink" title="自定义泛型方法"></a>自定义泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;T,R...&gt; 返回类型 方法名(参数列表)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>泛型方法，可以定义在普通类中，也可以定义在泛型类中</li>
<li>当泛型方法<strong>被调用时</strong>，类型会确定</li>
<li><code>public void eat(E e)&#123;&#125;</code>,修饰符后没有&lt;&gt;，所以该方法<strong>不是泛型方法</strong>，而是<strong>使用了泛型的普通方法</strong></li>
</ul>
<h4 id="泛型的继承和通配符"><a href="#泛型的继承和通配符" class="headerlink" title="泛型的继承和通配符"></a>泛型的继承和通配符</h4><ul>
<li>泛型不具备<strong>继承性</strong></li>
<li><?>：支持任意泛型类型</li>
<li><? extends A>：支持A类及A类的子类【决定了上限】</li>
<li><? super A>：支持A类及A的父类【决定了下限】</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220503170215686.png" alt="image-20220503170215686"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asahi.test;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">genetic_test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">daoTest</span><span class="params">()</span>&#123;</span><br><span class="line">        DAO&lt;User&gt; dao = <span class="keyword">new</span> <span class="title class_">DAO</span>&lt;&gt;();</span><br><span class="line">        dao.save(<span class="string">&quot;001&quot;</span>,<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;小红&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        dao.save(<span class="string">&quot;002&quot;</span>,<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>,<span class="string">&quot;小蓝&quot;</span>,<span class="number">25</span>));</span><br><span class="line">        dao.save(<span class="string">&quot;003&quot;</span>,<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">3</span>,<span class="string">&quot;小黑&quot;</span>,<span class="number">30</span>));</span><br><span class="line">        List&lt;User&gt; list = dao.list();</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        </span><br><span class="line">        dao.update(<span class="string">&quot;002&quot;</span>,<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>,<span class="string">&quot;ssss&quot;</span>,<span class="number">90</span>));</span><br><span class="line">        </span><br><span class="line">        System.out.println(dao.get(<span class="string">&quot;002&quot;</span>));</span><br><span class="line">        dao.delete(<span class="string">&quot;001&quot;</span>);</span><br><span class="line">        list = dao.list();</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        System.out.println(dao.get(<span class="string">&quot;003&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DAO</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,T&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(String id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String id,T entity)</span>&#123;</span><br><span class="line">        map.put(id,entity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            list.add(get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String id)</span>&#123;</span><br><span class="line">        map.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(String id, T entity)</span>&#123;</span><br><span class="line">        map.put(id, entity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;\nUser&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220503170415781.png" alt="image-20220503170415781"></p>
<h2 id="线程（Thread）"><a href="#线程（Thread）" class="headerlink" title="线程（Thread）"></a>线程（Thread）</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul>
<li>进程是指运行中的程序</li>
<li>进程是程序的一次执行过程，或是正在运行的一个程序【是动态过程：有自身的产生、存在、消亡过程】</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul>
<li>线程由进程创建，是进程的一个实体</li>
<li>一个进程可以有多个线程</li>
<li>单线程：同一时刻，只允许执行一个线程</li>
<li>多线程：同一时刻，允许执行多个线程【不会造成线程<strong>阻塞</strong>】</li>
<li>并发：同一时刻，多个任务交替执行，单核CPU实现的多任务就是并发【一个人一边开车，一边接电话】</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220519104242308.png" alt="image-20220519104242308"></p>
<ul>
<li>并行：同一时刻，多个任务同时执行，多核CPU可以实现并行</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220519104346187.png" alt="image-20220519104346187"></p>
<ul>
<li>并发和并行可能同时存在</li>
<li>当所有线程结束时，进程才会结束</li>
<li>子线程也可以开启新的线程</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220519105801585.png" alt="image-20220519105801585"></p>
<h3 id="线程的使用方法"><a href="#线程的使用方法" class="headerlink" title="线程的使用方法"></a>线程的使用方法</h3><h4 id="创建线程的两种方式"><a href="#创建线程的两种方式" class="headerlink" title="创建线程的两种方式"></a>创建线程的两种方式</h4><ul>
<li>继承Thread类，重写run()方法</li>
<li>实现Runnable接口，重写run()方法</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220519104619158.png" alt="image-20220519104619158"></p>
<h5 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h5><ul>
<li>通过直接调用类的<code>start()</code>方法启动线程【不能直接调用run()方法】</li>
<li>直接调用run()方法不能启动子线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">A</span>().start();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程  &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello  &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h5><ul>
<li>创建一个Thread对象，将实现Runnable接口的类写入括号</li>
<li>通过调用Thread对象的<code>start()</code>方法启动线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">B</span>());</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程  &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;B的hello &quot;</span> + i++);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Start-方法"><a href="#Start-方法" class="headerlink" title="Start()方法"></a>Start()方法</h4><ul>
<li>实际上是调用<strong>本地的静态方法</strong><code>start0()</code>实现多线程【JVM调用】</li>
<li>start()方法调用start0()方法后，该线程不一定会立马执行，而是变为了可执行状态。</li>
<li>线程具体什么时候执行，取决于CPU的统一调度</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220519105711443.png" alt="image-20220519105711443"></p>
<h4 id="继承Thread-VS-实现Runnable接口"><a href="#继承Thread-VS-实现Runnable接口" class="headerlink" title="继承Thread VS 实现Runnable接口"></a>继承Thread VS 实现Runnable接口</h4><ul>
<li>本质上没有区别，Thread类实现了Runnable接口</li>
<li>实现Runnable接口方式更加<strong>适合多个线程共享一个资源</strong>，避免了单继承的限制【多个窗口同时售票问题】</li>
<li>推荐使用Runnable</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asahi.Thread_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TicketSell</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Conductor01</span> <span class="variable">conductor01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Conductor01</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(conductor01);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(conductor01);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(conductor01);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Conductor01</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;票已售完~~&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;窗口&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 售出一张票&quot;</span> + <span class="string">&quot; 剩余票数: &quot;</span> + --count);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><ul>
<li>当线程完成任务会自动退出</li>
<li>可以通过使用变量来控制run()方法推出的方式停止线程，即<strong>通知方式</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asahi.Thread_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//t1.setPriority(Thread.MIN_PRIORITY);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hi &quot;</span>  +  i);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        t1.setLoop(<span class="literal">false</span>);<span class="comment">//控制run方法的运行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        System.out.println(t1.getName() + &quot; 的优先级是：&quot; + t1.getPriority());</span></span><br><span class="line"><span class="comment">        t1.interrupt();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;结束~~~&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoop</span><span class="params">(<span class="type">boolean</span> loop)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loop = loop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(loop)&#123;<span class="comment">//通过变量loop控制run方法的执行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;婷宝正在吃包子&quot;</span> + j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;休眠被中断了~~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="线程的常用方法"><a href="#线程的常用方法" class="headerlink" title="线程的常用方法"></a>线程的常用方法</h3><h4 id="常用方法第一组"><a href="#常用方法第一组" class="headerlink" title="常用方法第一组"></a>常用方法第一组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.setName //设置线程名称,使之与参数 name相同</span></span><br><span class="line"><span class="comment">2.getName //返回该线程的名称</span></span><br><span class="line"><span class="comment">3.start //是现成开始执行；java虚拟机底层调用该线程的start0方法</span></span><br><span class="line"><span class="comment">4.run //调用线程对象的run方法</span></span><br><span class="line"><span class="comment">5.setPriority //更改线程的优先级</span></span><br><span class="line"><span class="comment">6.getPriority //获取线程的优先级</span></span><br><span class="line"><span class="comment">7.sleep //在指定的毫秒数内让当前正在执行的线程休眠【暂停执行】</span></span><br><span class="line"><span class="comment">8.interrupt //中断线程</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ol>
<li>start底层会创建新的线程，调用run，run就是一个简单的方法调用，不会启动新线程</li>
<li>线程优先级的范围【0—10】</li>
<li>interrupt，中断线程，但并没有真正结束线程【一般用于中断正在休眠的线程】</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asahi.Thread_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        t1.start();</span><br><span class="line">        t1.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hi &quot;</span>  +  i);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//t1.setLoop(false);</span></span><br><span class="line"></span><br><span class="line">        System.out.println(t1.getName() + <span class="string">&quot; 的优先级是：&quot;</span> + t1.getPriority());</span><br><span class="line">        t1.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程结束~~~&quot;</span>);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoop</span><span class="params">(<span class="type">boolean</span> loop)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loop = loop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(loop)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;婷宝正在吃包子&quot;</span> + j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;休眠被中断了~~~&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;继续吃包子&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>sleep：线程的静态方法，使当前线程休眠</li>
</ol>
<h4 id="常用方法第二组"><a href="#常用方法第二组" class="headerlink" title="常用方法第二组"></a>常用方法第二组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.yield:线程的礼让。让出CPU，让其他线程执行，但礼让的时间不确定，所以也不一定成功【CPU管够的情况下一般不会成功】</span></span><br><span class="line"><span class="comment">2.join:线程的插队。插队的线程一旦插队成功，则肯定先执行完插入的线程所有的任务【会造成线程阻塞】</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220519112352508.png" alt="image-20220519112352508"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220519112426576.png" alt="image-20220519112426576"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asahi.Thread_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Thread.sleep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadMentho</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">M</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">M</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在报数：&quot;</span> + i);</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">10</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;报数中止~~~&quot;</span>);</span><br><span class="line">                m.start();<span class="comment">//启动m线程</span></span><br><span class="line">                m.join();<span class="comment">//造成线程阻塞，m线程执行完之后main线程才能继续执行</span></span><br><span class="line">                <span class="comment">//Thread.yield();主线程礼让</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">M</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在报数：&quot;</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;报数完毕~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用户线程和守护线程（Daemon）"><a href="#用户线程和守护线程（Daemon）" class="headerlink" title="用户线程和守护线程（Daemon）"></a>用户线程和守护线程（Daemon）</h3><ul>
<li>用户线程：也叫工作线程，当任务的<strong>线程执行完</strong>或<strong>通知方式</strong>结束</li>
<li>守护线程：一般是为工作线程服务的，当<strong>所有的用户线程</strong>结束，守护线程结束</li>
<li>常见的守护线程：垃圾回收机制</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asahi.Thread_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Thread.sleep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Daemon_</span> &#123;<span class="comment">//主线程为用户线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Z</span>());</span><br><span class="line">        thread.setDaemon(<span class="literal">true</span>);<span class="comment">//将Z的线程设置为守护线程</span></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程~~~~&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程结束~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Z</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;守护线程~~~~~&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><ul>
<li>物种状态：新建、就绪、运行、阻塞、死亡</li>
</ul>
<ol>
<li>新建： 当一个Thread类或其子类的对象<strong>被声明并创建</strong>时，新生的线程对象处于新建状态</li>
<li>就绪：处于新建状态的线程<strong>调用start()后</strong>，将进入<strong>线程队列等待CPU</strong>，此时它已<strong>具备了运行的条</strong>件，只是<strong>没分配到CPU资源</strong></li>
<li>运行：当就绪的线程<strong>被调度并获得CPU资源</strong>时,便进入运行状态， run()方法定义了线程的操作和功能</li>
<li>阻塞：在特殊情况下，<strong>被人为挂起</strong>或<strong>执行输入输出操作</strong>时，<strong>让出 CPU</strong> 并<strong>临时中止</strong>自己的执行，进入阻塞状态【只要不被唤醒，调度器就不会考虑调度】</li>
<li>死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220519134821531.png" alt="image-20220519134821531"></p>
<ul>
<li>JDK中用Thread.State枚举了线程的六种状态</li>
</ul>
<ol>
<li>NEW【尚未启动的线程】</li>
<li>RUNNABLE【在java虚拟机中执行的线程】<ul>
<li>READY【就绪】</li>
<li>RUNNING【运行中】</li>
</ul>
</li>
<li>BLOCKED【被阻塞等待监视器锁定的线程】</li>
<li>WAITING【正在等待另一个线程执行特定动作的线程】</li>
<li>TIMED_WAITING【正在等待另一个线程执行动作达到指定等待时间的线程】</li>
<li>TERMINATED【已退出的线程】</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220519134223043.png" alt="image-20220519134223043"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadState_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        System.out.println(t.getName() + <span class="string">&quot; 状态 &quot;</span> + t.getState());</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">while</span> (Thread.State.TERMINATED != t.getState()) &#123;</span><br><span class="line">            System.out.println(t.getName() + <span class="string">&quot; 状态 &quot;</span> + t.getState());</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(t.getName() + <span class="string">&quot; 状态 &quot;</span> + t.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hi &quot;</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="线程同步（Synchronized）"><a href="#线程同步（Synchronized）" class="headerlink" title="线程同步（Synchronized）"></a>线程同步（Synchronized）</h3><ul>
<li>在多线程编程，一些敏感数据不预序被多个线程同时访问，此时就使用同步访问技术，保证数据<strong>在任何同一时刻</strong>，<strong>最多有一个线程访问</strong>，以<strong>保证数据的完整性</strong></li>
<li>当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，知道该线程完成操作，其他线程才能对该内存地址进行操作</li>
</ul>
<h4 id="同步具体方法"><a href="#同步具体方法" class="headerlink" title="同步具体方法"></a>同步具体方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">U</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">N</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">U</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">U</span>();</span><br><span class="line">    <span class="comment">//Object object = new Object();</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(loop)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sell();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;售票结束~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//new Object()属于是每次都是一个新的锁</span></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="comment">/*this*/</span> <span class="comment">/*new Object()*/</span> u) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                loop = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="comment">//必须是同一个对象，且可以是任意对象</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 剩余票数：&quot;</span> + --count);</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>同步代码块</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;<span class="comment">//得到对象的锁，才能操作同步代码</span></span><br><span class="line">    <span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非静态</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                loop = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 剩余票数：&quot;</span> + --count);</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (N.class)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>放在方法声明中，表示整个方法为同步方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">(String name)</span>&#123;</span><br><span class="line">	<span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非静态方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            loop = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 剩余票数：&quot;</span> + --count);</span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sell2</span><span class="params">()</span>&#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="同步原理"><a href="#同步原理" class="headerlink" title="同步原理"></a>同步原理</h3><ul>
<li>操作的线程需要拿到对象锁才能对内存地址进行操作，用完放回去接着抢【同一个线程可以多次拿到对象锁】</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220519170350307.png" alt="image-20220519170350307"></p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><ol>
<li>java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性</li>
<li>每个对象都对应一个可称为<strong>互斥锁</strong>的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象</li>
<li>关键字<code>synchronized</code>来与对象的互斥锁联系，当某个对象用该关键字修饰时，表明该对象在任一时刻只能由一个线程来访问</li>
<li>同步的局限性：导致程序的执行效率降低</li>
<li>同步方法（非静态的）的锁可以是<strong>this</strong>也可以是<strong>其他对象</strong>【要求是同一个对象】</li>
<li>同步方法（静态的）的锁为<strong>当前类本身</strong></li>
</ol>
<h4 id="注意事项和细节"><a href="#注意事项和细节" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ol>
<li>同步方法如果没有static修饰：默认锁对象为<strong>this</strong></li>
<li>如果方法用static修饰：默认锁对象为<strong>当前类.class</strong></li>
<li>实现的落地步骤<ul>
<li>分析需要上锁的代码</li>
<li>选择同步方式【尽量同步代码块】</li>
<li>要求多个线程的锁对象为同一个</li>
</ul>
</li>
<li>如果继承Thread类时，新创建的对象的<strong>this锁是不一样的</strong>，会锁不住代码【推荐使用实现Runnable接口】</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">M</span> <span class="variable">m1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">M</span>();</span><br><span class="line"><span class="type">M</span> <span class="variable">m2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">M</span>();</span><br><span class="line"><span class="comment">//两个对象的this锁不一至，锁不住代码</span></span><br><span class="line">m1.start();</span><br><span class="line">m2.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">M</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="comment">//需要被锁的代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><ul>
<li>当前线程的同步方法、同步代码块执行结束</li>
<li>当线程在同步代码块，同步方法中遇到break、return</li>
<li>当前线程同步代码块，同步方法中出现了未处理的Error或Exception，导致异常结束</li>
<li>同步代码块，同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁</li>
</ul>
<h4 id="不会释放锁的操作"><a href="#不会释放锁的操作" class="headerlink" title="不会释放锁的操作"></a>不会释放锁的操作</h4><ul>
<li>线程调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行，不会释放锁</li>
<li>其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁【尽量避免使用suspend()和resume()来控制线程】</li>
</ul>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul>
<li>文件是保存数据的地方，既可以保存图片，也可以保存视频，声音</li>
<li>文件在程序中是以流的形式来操作的</li>
<li>流：数据在数据源【文件】和程序【内存】之间经历的路径</li>
<li>输入流：数据从数据源【文件】到程序【内存】的路径</li>
<li>输出流：数据从程序【内存】到数据源【文件】的路径</li>
</ul>
<h3 id="文件的相关操作"><a href="#文件的相关操作" class="headerlink" title="文件的相关操作"></a>文件的相关操作</h3><h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><ul>
<li>三种构造器</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220530225853089.png" alt="image-20220530225853089"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">creatFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       <span class="comment">//第一种</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;g:\\news1.txt&quot;</span>;</span><br><span class="line">       <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">       file1.createNewFile();</span><br><span class="line">       System.out.println(<span class="string">&quot;文件创建成功~&quot;</span>);</span><br><span class="line">       <span class="comment">//第二种</span></span><br><span class="line">       <span class="type">File</span> <span class="variable">file2_1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;g:\\&quot;</span>);</span><br><span class="line">       <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;news2.txt&quot;</span>;</span><br><span class="line">       <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file2_1,fileName);</span><br><span class="line">       file2.createNewFile();</span><br><span class="line">       System.out.println(<span class="string">&quot;文件创建成功！&quot;</span>);</span><br><span class="line">       <span class="comment">//第三种</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">parentPath</span> <span class="operator">=</span> <span class="string">&quot;g:\\&quot;</span>;</span><br><span class="line">       <span class="type">String</span> <span class="variable">chileName</span> <span class="operator">=</span> <span class="string">&quot;news3.txt&quot;</span>;</span><br><span class="line">       <span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentPath,chileName);</span><br><span class="line">       file3.createNewFile();</span><br><span class="line">       System.out.println(<span class="string">&quot;文件创建成功￥￥&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="常用的API"><a href="#常用的API" class="headerlink" title="常用的API"></a>常用的API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//先创建文件对象</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:\\news1.txt&quot;</span>);</span><br><span class="line"><span class="comment">//调用相应的方法，得到对应信息</span></span><br><span class="line">System.out.println(<span class="string">&quot;文件名字=&quot;</span> + file.getName());</span><br><span class="line"><span class="comment">//getName、getAbsolutePath、getParent、length、exists、isFile、isDirectory</span></span><br><span class="line">System.out.println(<span class="string">&quot;文件绝对路径=&quot;</span> + file.getAbsolutePath());</span><br><span class="line">System.out.println(<span class="string">&quot;文件父级目录=&quot;</span> + file.getParent());</span><br><span class="line">System.out.println(<span class="string">&quot;文件大小(字节)=&quot;</span> + file.length());</span><br><span class="line">System.out.println(<span class="string">&quot;文件是否存在=&quot;</span> + file.exists());<span class="comment">//T</span></span><br><span class="line">System.out.println(<span class="string">&quot;是不是一个文件=&quot;</span> + file.isFile());<span class="comment">//T</span></span><br><span class="line">System.out.println(<span class="string">&quot;是不是一个目录=&quot;</span> + file.isDirectory());<span class="comment">//F</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="目录的操作和文件删除"><a href="#目录的操作和文件删除" class="headerlink" title="目录的操作和文件删除"></a>目录的操作和文件删除</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220530231508129.png" alt="image-20220530231508129"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除文件、目录</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>&#123;</span><br><span class="line">    	<span class="comment">//String filePath = &quot;g:\\demo&quot;;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;g:\\news1.txt&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">        <span class="keyword">if</span>(file.exists())&#123;</span><br><span class="line">            <span class="keyword">if</span>(file.delete())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;删除成功~&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;删除失败~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件不存在~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建目录</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createDirectory</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">directoryPath</span> <span class="operator">=</span> <span class="string">&quot;g:\\demo\\a\\b\\c&quot;</span>;</span><br><span class="line">  <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(directoryPath);</span><br><span class="line">  <span class="keyword">if</span>(file.exists())&#123;</span><br><span class="line">        System.out.println(directoryPath + <span class="string">&quot;已存在&quot;</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(file.mkdirs())&#123;</span><br><span class="line">       System.out.println(directoryPath + <span class="string">&quot;创建成功&quot;</span>);</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(directoryPath + <span class="string">&quot;创建失败&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="IO流原理"><a href="#IO流原理" class="headerlink" title="IO流原理"></a>IO流原理</h3><ul>
<li>I&#x2F;O是Input&#x2F;Output的缩写，用于处理数据传输。如读、写，网络通讯等</li>
<li>java程序中，对数据的输入&#x2F;输出操作以<strong>流（stream）</strong>的方式进行</li>
<li>java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过方法输入或输出数据</li>
<li>输入input：读取<strong>外部数据</strong>【磁盘、光盘等储存设备的数据】到程序（内存）中</li>
<li>输出output：将<strong>程序</strong>（内存）数据输出到磁盘、光盘等储存设备中</li>
</ul>
<h2 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h2><ul>
<li>按操作数据单位不同分为：字节流（8 bit）二进制文件【图像，音频，视频等】，字符流（按字符）文本文件</li>
<li>按数据流的流向不同分为：输入流，输出流</li>
<li>按流的角色不同分为：节点流，处理流&#x2F;包装流</li>
<li>操作之后必须关闭资源，调用close()方法</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220530234646687.png" alt="image-20220530234646687"></p>
<h3 id="节点流"><a href="#节点流" class="headerlink" title="节点流"></a>节点流</h3><h4 id="字节流（InputStream-x2F-outputStream）"><a href="#字节流（InputStream-x2F-outputStream）" class="headerlink" title="字节流（InputStream&#x2F;outputStream）"></a>字节流（InputStream&#x2F;outputStream）</h4><ul>
<li>可以完成文件的<strong>无损操作</strong></li>
<li>以File—为例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inputStreamPro</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//文件路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;g:\\news2.txt&quot;</span>;</span><br><span class="line">        <span class="comment">//定义字节流读取对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//定义字节读取数组</span></span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="comment">//读取的字节长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建字节流读取文件</span></span><br><span class="line">            fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">            <span class="keyword">while</span> ((readLen = fileInputStream.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//将字符数组转化为字符串</span></span><br><span class="line">                System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, readLen));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileInputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outputStream</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//文件路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;g:\\text.txt&quot;</span>;</span><br><span class="line">        <span class="comment">//定义文件输出对象</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//初始化文件输出对象</span></span><br><span class="line">            fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath);<span class="comment">//覆盖</span></span><br><span class="line">            <span class="comment">//fileOutputStream = new FileOutputStream(filePath,true);//追加</span></span><br><span class="line">            <span class="comment">//需要输出的字符串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">note</span> <span class="operator">=</span> <span class="string">&quot;hello,world!!!!!!&quot;</span>;</span><br><span class="line">            <span class="comment">//将note写入text文本50次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                write(byte[],int off,int len)</span></span><br><span class="line"><span class="comment">                off：从off下标开始读取</span></span><br><span class="line"><span class="comment">                len：向后读取多少个字节</span></span><br><span class="line"><span class="comment">                需要传入字符数组</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="comment">//字符串自带.getBytes()方法，将字符串转化为字符数组</span></span><br><span class="line">                fileOutputStream.write(note.getBytes(), <span class="number">0</span>, note.length());</span><br><span class="line">                fileOutputStream.write(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;输出成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileOutputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="字节输入输出流完成无损拷贝"><a href="#字节输入输出流完成无损拷贝" class="headerlink" title="字节输入输出流完成无损拷贝"></a>字节输入输出流完成无损拷贝</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">picCopy</span><span class="params">()</span> </span><br><span class="line">        <span class="comment">//源文件地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">scrPath</span> <span class="operator">=</span> <span class="string">&quot;g:\\39488977_p0_master1200.jpg&quot;</span>;</span><br><span class="line">        <span class="comment">//输出文件地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">destPath</span> <span class="operator">=</span> <span class="string">&quot;g:\\milai.jpg&quot;</span>;</span><br><span class="line">    	<span class="comment">//定义字节输入/输出对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//字节流数组，提高读取效率</span></span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//读取文件数据长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dataLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(scrPath);</span><br><span class="line">            fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destPath);</span><br><span class="line">            <span class="keyword">while</span> ((dataLen = fileInputStream.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//一边读一边写</span></span><br><span class="line">                fileOutputStream.write(buf, <span class="number">0</span>, dataLen);<span class="comment">//一定要用这个方法</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;复制成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//分别关闭文件资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fileInputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                    fileInputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;en</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fileOutputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                    fileOutputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符流（Reader-x2F-Writer）"><a href="#字符流（Reader-x2F-Writer）" class="headerlink" title="字符流（Reader&#x2F;Writer）"></a>字符流（Reader&#x2F;Writer）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FileReader</span></span><br><span class="line"><span class="number">1.</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(File/String)</span><br><span class="line"><span class="number">2.</span> read():读取单个字符，读到末尾返回-<span class="number">1</span></span><br><span class="line"><span class="number">3.</span> read(cahr[]):批量读取多个字符到数组，返回读取到的字符数，读到末尾返回-<span class="number">1</span></span><br><span class="line"><span class="number">4.</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[]):将字符数组转换为字符串</span><br><span class="line"><span class="number">5.</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[],off,len):从指定位置指定长度转化为字符串</span><br><span class="line"> </span><br><span class="line"><span class="comment">//FileWriter</span></span><br><span class="line"><span class="number">1.</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(File/String,<span class="literal">true</span>)<span class="comment">//追加模式，默认覆盖</span></span><br><span class="line"><span class="number">2.</span> write()<span class="comment">//基本同read</span></span><br><span class="line"><span class="number">3.</span> String类: toCharArray:将字符串转化为字符数组</span><br></pre></td></tr></table></figure>

<ul>
<li>FileWriter使用后必须要close【关闭】和flush【刷新】,否则写入不到指定的文件</li>
</ul>
<h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><ul>
<li>基本同字节流</li>
<li>主要用于文本文件，效率高</li>
</ul>
<h3 id="处理流-x2F-包装流"><a href="#处理流-x2F-包装流" class="headerlink" title="处理流&#x2F;包装流"></a>处理流&#x2F;包装流</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220606083904341.png" alt="image-20220606083904341"></p>
<ul>
<li>节点流是底层流&#x2F;低级流，直接跟数据源相接</li>
<li>处理流<strong>包装节点流</strong>，既可以消除不同系欸但流的实现差异，也可以提供更方便的方法来完成输出</li>
<li>处理流对节点流进行包装使用了<strong>修饰器设计模式</strong>，不会直接与数据相连</li>
<li>主要功能：<ul>
<li>性能的提高：主要以增加缓冲的方式来提高输入输出的效率</li>
<li>操作的便捷：处理流可能提供了一系列便捷的方法来一次输入输出大批量的数据，使用更加灵活方便</li>
</ul>
</li>
</ul>
<h4 id="处理流-BufferedReader-和-BufferedWriter"><a href="#处理流-BufferedReader-和-BufferedWriter" class="headerlink" title="处理流-BufferedReader 和 BufferedWriter"></a>处理流-BufferedReader 和 BufferedWriter</h4><ul>
<li>属于字符流</li>
<li>关闭流处理流时，只需关闭外层流即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fileCOpy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">srcPath</span> <span class="operator">=</span> <span class="string">&quot;g:\\hello.java&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">destPath</span> <span class="operator">=</span> <span class="string">&quot;g:\\hello2.java&quot;</span>;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//按行读取，效率更高</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bufferedReader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(srcPath));</span><br><span class="line">            bufferedWriter = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(destPath));</span><br><span class="line">            <span class="comment">//读到行尾为null</span></span><br><span class="line">            <span class="keyword">while</span>((line = bufferedReader.readLine())!= <span class="literal">null</span>)&#123;</span><br><span class="line">                bufferedWriter.write(line);</span><br><span class="line">                <span class="comment">//插入换行</span></span><br><span class="line">                bufferedWriter.newLine();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;copy成功~&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bufferedReader.close();</span><br><span class="line">                bufferedWriter.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="BufferedOutputStream-和-BufferedInputStream"><a href="#BufferedOutputStream-和-BufferedInputStream" class="headerlink" title="BufferedOutputStream 和 BufferedInputStream"></a>BufferedOutputStream 和 BufferedInputStream</h4><ul>
<li>可以操作二进制文件，也可以操作文本文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">srcFilePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a.java&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">destFilePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a3.java&quot;</span>;</span><br><span class="line">        <span class="comment">//创建 BufferedOutputStream 对象 BufferedInputStream 对象</span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//因为 FileInputStream 是 InputStream 子类</span></span><br><span class="line">            bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFilePath));</span><br><span class="line">            bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFilePath));</span><br><span class="line">            <span class="comment">//循环的读取文件，并写入到 destFilePath</span></span><br><span class="line">            <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//当返回 -1 时，就表示文件读取完毕</span></span><br><span class="line">            <span class="keyword">while</span> ((readLen = bis.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(buff, <span class="number">0</span>, readLen);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件拷贝完毕~~~&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//关闭流 , 关闭外层的处理流即可，底层会去关闭节点流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bis != <span class="literal">null</span>) &#123;</span><br><span class="line">                    bis.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (bos != <span class="literal">null</span>) &#123;</span><br><span class="line">                    bos.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><ul>
<li>序列化就是在保存数据时，保存<strong>数据的值</strong>和<strong>数据类型</strong></li>
<li>反序列化就是在回复数据时，恢复<strong>数据的值</strong>和<strong>数据类型</strong></li>
<li>需要让某个对象支持序列化机制，必须让其类是可序列化的</li>
<li>为了让某个类是可序列化的，类必须实现如下两个接口之一<ul>
<li>Serializable【标记接口，没有方法】</li>
<li>Externalizable【该接口需要实现方法，因此一般实现上面的Serializable接口】</li>
</ul>
</li>
</ul>
<h4 id="对象流-ObjectInputStream-和-ObjectOutputStream、"><a href="#对象流-ObjectInputStream-和-ObjectOutputStream、" class="headerlink" title="对象流-ObjectInputStream 和 ObjectOutputStream、"></a>对象流-ObjectInputStream 和 ObjectOutputStream、</h4><ul>
<li>提供了对基本类型或对象类型的序列化和反序列化的方法</li>
<li>ObjectOutputStream 提供 序列化</li>
<li>ObjectInputStream 提供 反序列化功</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化后保存的文件格式不是文本，是按照他的格式来的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">objectOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;g:\\oos.dat&quot;</span>;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath));</span><br><span class="line">        oos.writeInt(<span class="number">100</span>);<span class="comment">// int -&gt; Integer (实现了 Serializable)</span></span><br><span class="line">        oos.writeBoolean(<span class="literal">true</span>);<span class="comment">// boolean -&gt; Boolean (实现了 Serializable)</span></span><br><span class="line">        oos.writeChar(<span class="string">&#x27;a&#x27;</span>);<span class="comment">// char -&gt; Character (实现了 Serializable)</span></span><br><span class="line">        oos.writeDouble(<span class="number">9.5</span>);<span class="comment">// double -&gt; Double (实现了 Serializable)</span></span><br><span class="line">        oos.writeUTF(<span class="string">&quot;韩顺平教育&quot;</span>);<span class="comment">//String</span></span><br><span class="line">    	<span class="comment">//确保该类的对象可以序列化且可以被引用到</span></span><br><span class="line">    	oos.writeObject(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">18</span>,<span class="string">&quot;大黄&quot;</span>));</span><br><span class="line">        oos.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化保存完毕~&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建流对象</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\data.dat&quot;</span>));</span><br><span class="line"><span class="comment">// 2.读取， 注意顺序</span></span><br><span class="line">System.out.println(ois.readInt());</span><br><span class="line">System.out.println(ois.readBoolean());</span><br><span class="line">System.out.println(ois.readChar());</span><br><span class="line">System.out.println(ois.readDouble());</span><br><span class="line">System.out.println(ois.readUTF());</span><br><span class="line">System.out.println(ois.readObject());</span><br><span class="line">System.out.println(ois.readObject());</span><br><span class="line">System.out.println(ois.readObject());</span><br><span class="line"><span class="comment">// 3.关闭</span></span><br><span class="line">ois.close();</span><br><span class="line">System.out.println(<span class="string">&quot;以反序列化的方式读取(恢复)ok~&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>注意事项：</li>
</ul>
<ol>
<li>读写顺序要一致</li>
<li>要求序列化或反序列化的对象，需要实现<strong>Serializable</strong></li>
<li>序列化的类中建议添加<strong>serialVersionUID</strong>,为了提高版本的兼容性</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">//显式声明serialVersionUID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h4><ul>
<li><p>System.in </p>
<ul>
<li><p><code>public final static InputStream</code></p>
</li>
<li><p>编译类型：InputSream</p>
</li>
<li><p>运行类型：BufferedInputSream</p>
</li>
</ul>
</li>
<li><p>System.out</p>
<ul>
<li><code>public final static PrintStream</code></li>
<li>编译类型：PrintStream</li>
<li>运行类型：PrintStream</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220606185008671.png" alt="image-20220606185008671"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220606185030256.png" alt="image-20220606185030256"></p>
<h4 id="转换流-InputStreamReader-和-OutputStreamWriter"><a href="#转换流-InputStreamReader-和-OutputStreamWriter" class="headerlink" title="转换流-InputStreamReader 和 OutputStreamWriter"></a>转换流-InputStreamReader 和 OutputStreamWriter</h4><ul>
<li>InputStreamReader：Reader的子类，可以将字节流InputStream<strong>包装（转换）</strong>成字符流Reader</li>
<li>OutputStreamWriter：Writer的子类，可以将字节流OutputStream<strong>包装（转换）</strong>成字符流Writer</li>
<li>处理纯文本数据时，如果使用字符流效率更高，并且有效解决中文乱码问题，所以建议将字节流转换成字符流</li>
<li><strong>可以在使用时指定文件编码格式</strong></li>
<li><strong>一定要关流！！！！</strong></li>
<li>案例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将字节流FileInputStream包装成字符流InputStreamReader，对文件进行读取（指定编码格式），进而再包装成BufferedReader</span></span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inputStreamReader</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;g:\\text.txt&quot;</span>;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> 	<span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath), <span class="string">&quot;gbk&quot;</span>));</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span>((line = isr.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//将字节流FileOutputStream包装成字符流InputStreamReader，对文件进行写入（指定编码格式）</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outputStreamWriter</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;g:\\text.txt&quot;</span>;</span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath), <span class="string">&quot;UTF8&quot;</span>);</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(osw);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            bw.write(<span class="string">&quot;杰杰，小小的，香香的~~~&quot;</span>);</span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//务必关流</span></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定编码方式拷贝</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">txtcopy</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">srcPath</span> <span class="operator">=</span> <span class="string">&quot;g:\\text.txt&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">destPath</span> <span class="operator">=</span> <span class="string">&quot;g:\\demo.txt&quot;</span>;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcPath), <span class="string">&quot;gbk&quot;</span>));</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destPath), <span class="string">&quot;gbk&quot;</span>));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">            bw.write(line);</span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="打印流-PrintStream-和-PrintWrite"><a href="#打印流-PrintStream-和-PrintWrite" class="headerlink" title="打印流-PrintStream 和 PrintWrite"></a>打印流-PrintStream 和 PrintWrite</h4><ul>
<li>只有输出流，没有输入流</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> System.out;</span><br><span class="line">        out.write(<span class="string">&quot;杰杰&quot;</span>.getBytes());</span><br><span class="line">		out.close();</span><br><span class="line">        System.setOut(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;g:f1.txt&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220606203825218.png" alt="image-20220606203825218"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void printWriter() throws IOException &#123;</span><br><span class="line">       PrintWriter printWriter = new PrintWriter(new FileWriter(&quot;g:\\f2.txt&quot;));</span><br><span class="line">       printWriter.println(&quot;啊哈哈哈哈哈哈哈哈哈&quot;);</span><br><span class="line">       printWriter.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220606203858109.png" alt="image-20220606203858109"></p>
<h3 id="Properties-类"><a href="#Properties-类" class="headerlink" title="Properties 类"></a>Properties 类</h3><ul>
<li>专门用于读写配置文件的集合类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置文件格式</span></span><br><span class="line">键=值</span><br><span class="line">键=值</span><br></pre></td></tr></table></figure>

<ul>
<li>注意键值之间不需要有空格，值不需要引号引起来【默认类型是String】</li>
</ul>
<h4 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h4><ul>
<li>load：加载配置文件到Properties对象</li>
<li>list：将数据显示到指定<strong>设备</strong></li>
<li>getProperty(key)：根据键获取值</li>
<li>setProperty(key,value)：设置键值对到Properties对象</li>
<li>store：将Properties中的键值对储存到配置文件，在idea中，保存配置文件如果有中文，会储存为unicode码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       <span class="comment">//创建Properties对象</span></span><br><span class="line">       <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">       <span class="comment">//加载配置文件</span></span><br><span class="line">       properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">       <span class="comment">//获取指定键值对</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">       <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;pwd&quot;</span>);</span><br><span class="line">       <span class="comment">//加入新的键值对</span></span><br><span class="line">       properties.setProperty(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line">       <span class="comment">//修改键值对</span></span><br><span class="line">       properties.setProperty(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;啊哈哈&quot;</span>);</span><br><span class="line">       <span class="comment">//写入配置文件,null位置是注释</span></span><br><span class="line">       properties.store(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>),<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><ul>
<li>概念：两台设备之间通过网络实现数据传输</li>
<li>网络通信：将数据通过网络从一台设备传输到另一台设备</li>
<li>java.net包下提供了一系列的类和接口供程序员使用</li>
</ul>
<h2 id="网络-1"><a href="#网络-1" class="headerlink" title="网络"></a>网络</h2><ul>
<li>概念：两台或多台设备通过一定物理设备连接起来构成的网络</li>
<li>根据覆盖范围不同，分为：<ul>
<li>局域网：覆盖范围较小，仅仅一个教室或者机房</li>
<li>城域网：覆盖范围较大，可以覆盖一个城市</li>
<li>广域网：覆盖范围最大，可以覆盖全国，甚至全球，万维网是广域网的代表</li>
</ul>
</li>
</ul>
<h2 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址"></a>ip地址</h2><ul>
<li>概念：用于唯一标识网络中的每台计算机&#x2F;主机【类似身份证】</li>
<li>查看ip地址：ipconfig</li>
<li>ip地址的表示形式：点分十进制 xx.xx.xx.xx</li>
<li>每一个十进制数的范围：0~255</li>
<li>ip地址的组成 &#x3D; 网络地址 + 主机地址，比如 195.168.16.69</li>
<li>iIPv6是互联网工程任务组设计的用于替代IPv4的下一代IP协议，号称可以为全世界每一粒沙子编上地址【16个字节，长度是IPv4的4倍】</li>
<li>IPv4最大的问题在于网络地址资源有限</li>
<li>IPv6的使用，不仅能解决网络地址资源数量的问题，而且也解决了多种接入设备连入互联网的障碍</li>
</ul>
<h3 id="IPv4地址分类"><a href="#IPv4地址分类" class="headerlink" title="IPv4地址分类"></a>IPv4地址分类</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220607131303897.png" alt="image-20220607131303897"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220607131321259.png" alt="image-20220607131321259"></p>
<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><ul>
<li>好处：为了方便记忆，解决记ip的困难</li>
<li>概念：将ip地址映射成域名【HTTP协议】</li>
</ul>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><ul>
<li>概念：用于标识计算机上某个特定的网络程序</li>
<li>表示形式：以整数形式，端口范围0<del>65535【2个字节表示端口 0</del>2^16-1】</li>
<li>0~1024已经被占用，比如 ssh 22，ftp 21，smtp 25 ， http 80</li>
<li>常见的网络程序端口号<ul>
<li>tomcat：8080</li>
<li>mysql：3306</li>
<li>oracle：1521</li>
</ul>
</li>
</ul>
<h2 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220607131740349.png" alt="image-20220607131740349"></p>
<h3 id="协议（TCP-x2F-IP）"><a href="#协议（TCP-x2F-IP）" class="headerlink" title="协议（TCP&#x2F;IP）"></a>协议（TCP&#x2F;IP）</h3><ul>
<li>TCP&#x2F;IP (Transmission Control Protocol &#x2F; Internet Protocol)的简写</li>
<li>中文译名为<strong>传输控制协议</strong>&#x2F;<strong>因特网互联协议</strong>，又叫<strong>网络通信协议</strong></li>
<li>是Internet最基本的协议、Internet国际互联网络的基础</li>
<li>简单的说，就是由<strong>网络的IP协议</strong>和<strong>传输层的TCP协议</strong>组成</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220607132257398.png" alt="image-20220607132257398"></p>
<h3 id="TCP：传输控制协议"><a href="#TCP：传输控制协议" class="headerlink" title="TCP：传输控制协议"></a>TCP：传输控制协议</h3><ul>
<li>使用TCP协议前，须先建立TCP连接，形成网络传输通道</li>
<li>传输前，采用“三次握手”方式，是<strong>可靠的</strong></li>
<li>TCP协议进行通信的两个应用进程：<strong>客户端</strong>、<strong>服务端</strong></li>
<li>在连接中可进行大数据量的传输</li>
<li>传输完毕，需释放已建立的连接，<strong>效率低</strong></li>
<li>举例：打电话</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220607133027973.png" alt="image-20220607133027973"></p>
<h3 id="UDP：用户数据协议"><a href="#UDP：用户数据协议" class="headerlink" title="UDP：用户数据协议"></a>UDP：用户数据协议</h3><ul>
<li>将数据、源、目的封装成数据包，不需要建立连接</li>
<li>每个数据包的大小限制在64K内，<strong>不适合传输大量数据</strong></li>
<li>因无需连接，故是<strong>不可靠的</strong></li>
<li>发送数据结束后无需释放资源【不是面向连接的】，<strong>速度快</strong></li>
<li>举例：厕所通知、发短信</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220607133110412.png" alt="image-20220607133110412"></p>
<h2 id="InetAddress-类"><a href="#InetAddress-类" class="headerlink" title="InetAddress 类"></a>InetAddress 类</h2><ul>
<li>此类表示互联网协议 (IP) 地址</li>
</ul>
<h3 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h3><ul>
<li>getLocalHost：获取本机InetAddress对象</li>
<li>getByName：获取指定主机名&#x2F;域名 的InetAddress对象</li>
<li>getHostName：获取InetAddress对象的主机名</li>
<li>getHostAdrress：获取InetAddress的地址</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inetAdrress</span><span class="params">()</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">       <span class="comment">//获取本机的ip地址对象</span></span><br><span class="line">       <span class="type">InetAddress</span> <span class="variable">host1</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">       System.out.println(host1);<span class="comment">//10.152.167.99</span></span><br><span class="line">       <span class="comment">//获取指定域名、服务器名的ip地址对象</span></span><br><span class="line">       <span class="type">InetAddress</span> <span class="variable">host2</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">       System.out.println(host2);</span><br><span class="line">       <span class="comment">//获取ip地址对象的域名、服务器名</span></span><br><span class="line">       System.out.println(host2.getHostName());</span><br><span class="line">       <span class="comment">//获取ip地址对象的ip地址</span></span><br><span class="line">       System.out.println(host2.getHostAddress());</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><ul>
<li>套接字（Socket）开发网络应用程序被广泛采用，以至于成为事实上的标准</li>
<li>通信的两端都要有Scoket，是两台机器间通信的端点</li>
<li>网络通信其实就是Socket间的通信</li>
<li>Socket允许程序<strong>把网络连接成一个流</strong>，数据在两个Socket间<strong>通过IO传输</strong></li>
<li>一般<strong>主动发起通信</strong>的应用程序属于<strong>客户端</strong>，<strong>等待通信请求</strong>的为<strong>服务端</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220607135300559.png" alt="image-20220607135300559"></p>
<h2 id="TCP-网络通信编程"><a href="#TCP-网络通信编程" class="headerlink" title="TCP 网络通信编程"></a>TCP 网络通信编程</h2><ul>
<li>基于<strong>客户端-服务端</strong>的通络通信</li>
<li>底层使用的是TCP&#x2F;IP协议</li>
<li>应用场景举例：客户端发送数据，服务端接收数据</li>
<li><strong>基于Socket的TCP编程</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220607135059077.png" alt="image-20220607135059077"></p>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h4 id="面试题01"><a href="#面试题01" class="headerlink" title="面试题01"></a>面试题01</h4><p>int i &#x3D; 1;</p>
<p>i &#x3D; i++;&#x2F;&#x2F; i &#x3D; 1</p>
<ul>
<li>temp &#x3D; i;&#x2F;&#x2F;temp &#x3D; 1;</li>
<li>i &#x3D; i++;&#x2F;&#x2F;i &#x3D; 2</li>
<li>i &#x3D; temp;&#x2F;&#x2F;i &#x3D; 1</li>
</ul>
<h4 id="面试题02"><a href="#面试题02" class="headerlink" title="面试题02"></a>面试题02</h4><p>int i &#x3D; 1;</p>
<p>i &#x3D; i++;&#x2F;&#x2F; i &#x3D; 1</p>
<ul>
<li>i &#x3D; i++;&#x2F;&#x2F;i &#x3D; 2</li>
<li>temp &#x3D; i;&#x2F;&#x2F;temp &#x3D; 2</li>
<li>i &#x3D; temp;&#x2F;&#x2F;i &#x3D; 2</li>
</ul>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>面试题03- equals()和&#x3D;&#x3D;的区别</p>
<ul>
<li>&#x3D;&#x3D;：比较运算符<ul>
<li>既可判断基本类型，也可判断引用类型</li>
<li>判断<strong>基本类型</strong>时，判断<strong>值</strong>是否相等</li>
<li>判断<strong>引用类型</strong>时，判断<strong>地址</strong>是否相同，即是不是同一个对象</li>
</ul>
</li>
<li>equals()：Object类的方法<ul>
<li>是Object类中的方法，<strong>只能判断引用类型</strong></li>
<li>其他各类都对equals()方法进行了重写，<strong>用于判断值是否相等</strong></li>
</ul>
</li>
</ul>
<hr>
<h3 id="编程小姿势"><a href="#编程小姿势" class="headerlink" title="编程小姿势"></a>编程小姿势</h3><h4 id="进制转换-x2F-多项式（霍纳算法）"><a href="#进制转换-x2F-多项式（霍纳算法）" class="headerlink" title="进制转换&#x2F;多项式（霍纳算法）"></a>进制转换&#x2F;多项式（霍纳算法）</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Asahi\AppData\Roaming\Typora\typora-user-images\image-20220307221713029.png" alt="image-20220307221713029"></p>
<p>![img](file:&#x2F;&#x2F;&#x2F;C:\Users\Asahi\Documents\Tencent Files\704763769\Image\C2C\Image1\D113F516D25CD18CEF9CCC27184EF637.jpg)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asahi.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HexToDec</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Mytools</span> <span class="variable">tools</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mytools</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">hex</span> <span class="operator">=</span> <span class="string">&quot;ab8C&quot;</span>;</span><br><span class="line">        System.out.println(tools.hexToDec(hex));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mytools</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hexToDec</span><span class="params">(String hex)</span>&#123;</span><br><span class="line">        hex = hex.toUpperCase();</span><br><span class="line">        <span class="type">int</span> <span class="variable">hexNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; hex.length(); i++) &#123;</span><br><span class="line">            hexNum = hexNum * <span class="number">16</span> + hexToNum(hex.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hexNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hexToNum</span><span class="params">(<span class="type">char</span> ch)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch &gt;= <span class="string">&#x27;1&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span> + ch - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>高内聚，低耦合</li>
<li>一段代码完成一个小功能</li>
<li>判断错误的情况，一条条列出，利于提高代码可读性</li>
</ul>
<hr>
<h3 id="java小细节"><a href="#java小细节" class="headerlink" title="java小细节"></a>java小细节</h3><ul>
<li>&#x2F;r &#x3D; “回车”，光标回到此行的开头位置</li>
<li>浮点数进行运算后的结果为<em><strong>近似值</strong></em> 进行比较时需要特别注意！！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两数相减的绝对值小于精确度，则认为两数相等</span></span><br><span class="line"><span class="keyword">if</span>(Math.abs(num1 - num2) &lt; <span class="number">0.00001</span>)&#123;</span><br><span class="line">    <span class="comment">//两数相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>加强运算符会自动进行强制类型转换</li>
<li>强转只作用于最近的操作数</li>
<li>byte、short能够进行运算，运算结果为int类型</li>
<li>a % b &#x3D; a - a &#x2F; b * b（只有当被除数为负数时才可能为负） </li>
<li>三元运算符当作一个整体</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="literal">true</span>? <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>) : <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(obj1);<span class="comment">//输出1.0</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-tutorial.html">Java 教程 | 菜鸟教程 (runoob.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1fh411y7R8?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click">【零基础 快速学Java】韩顺平</a></li>
<li><a target="_blank" rel="noopener" href="https://markdown.com.cn/basic-syntax/">Markdown 基本语法 | Markdown 官方教程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744">Java教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/judasn/IntelliJ-IDEA-Tutorial">IDEA 简体中文专题教程 </a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5de7cca0fefc">IntelliJ Idea 常用快捷键列表 - 简书 (jianshu.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://codegym.cc/zh/quests/lectures/zh.questsyntax.level01.lecture00">Course Java 语法 - Lecture: 你已经升级了！ (codegym.cc)</a></li>
<li>[韩顺平_循序渐进学Java零基础【完整笔记】.pdf](file:&#x2F;&#x2F;&#x2F;G:&#x2F;BaiduNetdiskDownload&#x2F;韩顺平 2021零基础学Java 【软件 资料 代码 笔记】&#x2F;笔记&#x2F;韩顺平_循序渐进学Java零基础【完整笔记】.pdf)</li>
<li>[Mysql5.7](G:\BaiduNetdiskDownload\韩顺平 2021零基础学Java 【软件 资料 代码 笔记】\资料\分享资料\分享资料)</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://asahif.github.io">Asahi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://asahif.github.io/2023/03/26/java/">https://asahif.github.io/2023/03/26/java/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://asahif.github.io" target="_blank">Asahi</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://service-5z0sdahv-1306777571.sh.apigw.tencentcs.com/release/" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/26/mysql/" title="mysql"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://service-5z0sdahv-1306777571.sh.apigw.tencentcs.com/release/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">mysql</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/26/%E5%B5%8C%E5%85%A5%E5%BC%8F/" title="嵌入式学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://service-5z0sdahv-1306777571.sh.apigw.tencentcs.com/release/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">嵌入式学习</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Asahi</div><div class="author-info__description">静待花开</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/AsahiF"><i class="fab fa-github"></i><span>Asahi小窝</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/AsahiF" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:704763769@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-Foundation"><span class="toc-number">1.</span> <span class="toc-text">Java Foundation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">java编译原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK%E3%80%81JRE"><span class="toc-number">1.0.0.2.</span> <span class="toc-text">JDK、JRE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">1.0.0.3.</span> <span class="toc-text">配置环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.0.0.4.</span> <span class="toc-text">java开发注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-x2F-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">1.0.0.5.</span> <span class="toc-text">java代码&#x2F;命名规范</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%84%E6%88%90"><span class="toc-number">1.0.0.6.</span> <span class="toc-text">JVM的内存组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E5%8C%96"><span class="toc-number">1.0.0.7.</span> <span class="toc-text">String类型与基本数据类型的转化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.0.0.8.</span> <span class="toc-text">关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E7%95%99%E5%AD%97"><span class="toc-number">1.0.0.9.</span> <span class="toc-text">保留字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.0.0.10.</span> <span class="toc-text">进制表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81"><span class="toc-number">1.0.0.11.</span> <span class="toc-text">原码、反码、补码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.0.0.12.</span> <span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%EF%BC%88loop%EF%BC%89"><span class="toc-number">1.0.0.13.</span> <span class="toc-text">循环（loop）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BAfor"><span class="toc-number">1.0.0.14.</span> <span class="toc-text">增强for</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.0.0.15.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%EF%BC%88%E5%80%BC%E6%8B%B7%E8%B4%9D-x2F-%E5%9C%B0%E5%9D%80%E6%8B%B7%E8%B4%9D%EF%BC%89"><span class="toc-number">1.0.0.16.</span> <span class="toc-text">赋值（值拷贝&#x2F;地址拷贝）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%EF%BC%88public%EF%BC%89%E4%BA%8E%E5%AF%B9%E8%B1%A1%EF%BC%88object%EF%BC%89"><span class="toc-number">1.0.1.</span> <span class="toc-text">类（public）于对象（object）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%9C%A8%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">对象在内存中的存在形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7-x2F-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-x2F-%E5%AD%97%E6%AE%B5%EF%BC%88field%EF%BC%89"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">属性&#x2F;成员变量&#x2F;字段（field）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">局部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8-x2F-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.1.4.</span> <span class="toc-text">构造器&#x2F;构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">1.0.1.5.</span> <span class="toc-text">对象创建的流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">1.0.1.6.</span> <span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0-x2F-%E5%AD%97%E7%AC%A6%E7%94%9F%E6%88%90"><span class="toc-number">1.0.1.7.</span> <span class="toc-text">随机数&#x2F;字符生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85"><span class="toc-number">1.0.1.8.</span> <span class="toc-text">包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.0.1.9.</span> <span class="toc-text">访问修饰符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%EF%BC%9A%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81"><span class="toc-number">1.1.</span> <span class="toc-text">面向对象的三大特征：封装、继承、多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%EF%BC%88encapsulation%EF%BC%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">封装（encapsulation）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">封装实现的步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">封装与构造器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%EF%BC%88extend%EF%BC%89"><span class="toc-number">1.1.2.</span> <span class="toc-text">继承（extend）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">super关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99-x2F-%E8%A6%86%E7%9B%96%EF%BC%88override%EF%BC%89"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">方法重写&#x2F;覆盖（override）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E5%88%9B%E5%BB%BA%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">子类创建的内存布局</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%EF%BC%88Polymorphism%EF%BC%89"><span class="toc-number">1.1.3.</span> <span class="toc-text">多态（Polymorphism）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-number">1.1.3.0.1.</span> <span class="toc-text">向上转型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="toc-number">1.1.3.0.2.</span> <span class="toc-text">向下转型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%BB%86%E8%8A%82"><span class="toc-number">1.1.3.0.3.</span> <span class="toc-text">多态细节</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.3.0.4.</span> <span class="toc-text">多态数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%8F%82%E6%95%B0"><span class="toc-number">1.1.3.0.5.</span> <span class="toc-text">多态参数.</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E7%9A%84%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">java的动态绑定机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashCode%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">hashCode方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#toString%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">toString方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95%EF%BC%88debug%EF%BC%89"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">断点调试（debug）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F-x2F-%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%88static%EF%BC%89"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">类变量&#x2F;类方法（static）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#main%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.3.6.</span> <span class="toc-text">main方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">1.1.4.</span> <span class="toc-text">代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%88static%EF%BC%89"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">静态代码块（static）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">非静态代码块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%B1%BB%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">创建一个类对象时，在一个类调用顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%88%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.5.</span> <span class="toc-text">创建一个子类对象时（继承关系）优先级问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A2%AB%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">类什么时候被加载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.6.</span> <span class="toc-text">单例设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">饿汉式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">懒汉式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8Fvs%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-number">1.1.6.3.</span> <span class="toc-text">饿汉式vs懒汉式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.1.6.4.</span> <span class="toc-text">final关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88abstract%EF%BC%89"><span class="toc-number">1.1.7.</span> <span class="toc-text">抽象类（abstract）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">抽象类使用的注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%EF%BC%88interface%EF%BC%89"><span class="toc-number">1.1.8.</span> <span class="toc-text">接口（interface）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%EF%BC%88interface%EF%BC%89vs-%E7%BB%A7%E6%89%BF%EF%BC%88entends%EF%BC%89"><span class="toc-number">1.1.9.</span> <span class="toc-text">接口（interface）vs 继承（entends）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88innerClass%EF%BC%89"><span class="toc-number">1.1.10.</span> <span class="toc-text">内部类（innerClass）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88%E6%9C%AC%E8%B4%A8%E4%BB%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E7%B1%BB%EF%BC%89"><span class="toc-number">1.1.10.1.</span> <span class="toc-text">局部内部类（本质仍是一个类）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.1.10.2.</span> <span class="toc-text">匿名内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.1.10.3.</span> <span class="toc-text">成员内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.1.10.4.</span> <span class="toc-text">静态内部类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%EF%BC%88enumeration%EF%BC%89"><span class="toc-number">1.1.11.</span> <span class="toc-text">枚举类（enumeration）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.1.11.1.</span> <span class="toc-text">自定义类实现枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#enum%E5%85%B3%E9%94%AE%E5%AD%97%E5%AE%9E%E7%8E%B0%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.1.11.2.</span> <span class="toc-text">enum关键字实现枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#enum%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.11.3.</span> <span class="toc-text">enum实现接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%EF%BC%88Annotation%EF%BC%89"><span class="toc-number">1.1.12.</span> <span class="toc-text">注解（Annotation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%EF%BC%88Exception%EF%BC%89"><span class="toc-number">1.1.13.</span> <span class="toc-text">异常（Exception）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%EF%BC%88Error%EF%BC%89"><span class="toc-number">1.1.13.1.</span> <span class="toc-text">错误（Error）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exception"><span class="toc-number">1.1.13.2.</span> <span class="toc-text">Exception</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E5%9B%BE"><span class="toc-number">1.1.13.3.</span> <span class="toc-text">异常体系图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="toc-number">1.1.13.4.</span> <span class="toc-text">常见的运行时异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="toc-number">1.1.13.5.</span> <span class="toc-text">常见的编译时异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.1.13.6.</span> <span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#try-catch-finally"><span class="toc-number">1.1.13.7.</span> <span class="toc-text">try-catch-finally</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#throws"><span class="toc-number">1.1.13.8.</span> <span class="toc-text">throws</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">1.1.13.9.</span> <span class="toc-text">自定义异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#throw-%E5%92%8Cthrows-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.13.10.</span> <span class="toc-text">throw 和throws 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">1.1.14.</span> <span class="toc-text">包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Integer%E7%B1%BB%EF%BC%88%E6%95%B0%E5%AD%A6%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-number">1.1.14.1.</span> <span class="toc-text">Integer类（数学类型）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB-gt-String"><span class="toc-number">1.1.14.2.</span> <span class="toc-text">包装类-&gt;String</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.14.3.</span> <span class="toc-text">常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Integer-x2F-Character%E7%B1%BB"><span class="toc-number">1.1.14.3.1.</span> <span class="toc-text">Integer&#x2F;Character类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.1.14.3.2.</span> <span class="toc-text">经典面试题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E7%B1%BB"><span class="toc-number">1.1.14.4.</span> <span class="toc-text">String类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAString%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.14.4.1.</span> <span class="toc-text">创建String对象的两种方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-number">1.1.14.4.2.</span> <span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringBuffer%E7%B1%BB"><span class="toc-number">1.1.14.5.</span> <span class="toc-text">StringBuffer类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E5%92%8CSrtingBuffer%E7%9A%84%E8%BD%AC%E5%8C%96"><span class="toc-number">1.1.14.6.</span> <span class="toc-text">String和SrtingBuffer的转化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#String-gt-SrtingBuffer"><span class="toc-number">1.1.14.6.1.</span> <span class="toc-text">String-&gt;SrtingBuffer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SrtingBuffer-gt-String"><span class="toc-number">1.1.14.6.2.</span> <span class="toc-text">SrtingBuffer-&gt;String</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-2"><span class="toc-number">1.1.14.6.3.</span> <span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SrtingBuilder%E7%B1%BB"><span class="toc-number">1.1.14.7.</span> <span class="toc-text">SrtingBuilder类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E3%80%81StringBuffer%E3%80%81StringBuilder%E6%AF%94%E8%BE%83"><span class="toc-number">1.1.14.8.</span> <span class="toc-text">String、StringBuffer、StringBuilder比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99"><span class="toc-number">1.1.14.9.</span> <span class="toc-text">使用原则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.15.</span> <span class="toc-text">Math类方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arrays%E7%B1%BB"><span class="toc-number">1.1.16.</span> <span class="toc-text">Arrays类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#System%E7%B1%BB"><span class="toc-number">1.1.17.</span> <span class="toc-text">System类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BigIteger%EF%BC%88%E5%A4%A7%E6%AD%A3%E6%95%B0%EF%BC%89%E5%92%8CBigDecimal%E7%B1%BB%EF%BC%88%E5%A4%A7%E5%88%86%E6%95%B0%EF%BC%89"><span class="toc-number">1.1.18.</span> <span class="toc-text">BigIteger（大正数）和BigDecimal类（大分数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-number">1.1.19.</span> <span class="toc-text">日期类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Date%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-number">1.1.19.1.</span> <span class="toc-text">Date：第一代日期类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Calendar%EF%BC%9A%E7%AC%AC%E4%BA%8C%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-number">1.1.19.2.</span> <span class="toc-text">Calendar：第二代日期类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LocalDate%E3%80%81LocalTime%E3%80%81LocalDateTime-%E7%AC%AC%E4%B8%89%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-number">1.1.19.3.</span> <span class="toc-text">LocalDate、LocalTime、LocalDateTime:第三代日期类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DateTimeFormatter%E6%A0%BC%E5%BC%8F%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-number">1.1.19.4.</span> <span class="toc-text">DateTimeFormatter格式日期类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Instant%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-number">1.1.19.5.</span> <span class="toc-text">Instant时间戳</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.19.6.</span> <span class="toc-text">更多方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">1.1.20.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB"><span class="toc-number">1.1.20.1.</span> <span class="toc-text">集合的框架体系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.21.</span> <span class="toc-text">Collection接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Collection%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.21.1.</span> <span class="toc-text">Collection接口的常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Collection%E6%8E%A5%E5%8F%A3%E9%81%8D%E5%8E%86%E5%85%83%E7%B4%A0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.21.2.</span> <span class="toc-text">Collection接口遍历元素方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Iterator%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%89"><span class="toc-number">1.1.21.3.</span> <span class="toc-text">Iterator（迭代器）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.21.3.1.</span> <span class="toc-text">执行原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.21.3.2.</span> <span class="toc-text">接口方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.1.21.4.</span> <span class="toc-text">增强for循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.22.</span> <span class="toc-text">List 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.22.1.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%92%8C%E5%8E%9F%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.1.22.2.</span> <span class="toc-text">ArrayList底层结构和原码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%92%8C%E5%8E%9F%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">1.1.22.3.</span> <span class="toc-text">Vector底层结构和原码剖析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E5%92%8CVector%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.22.4.</span> <span class="toc-text">ArrayList和Vector区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.23.</span> <span class="toc-text">LinkedList底层结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.23.1.</span> <span class="toc-text">底层操作机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.23.2.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E5%92%8CLinkedList%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.23.3.</span> <span class="toc-text">ArrayList和LinkedList区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.</span> <span class="toc-text">Set接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-3"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">遍历方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashSet"><span class="toc-number">1.3.</span> <span class="toc-text">HashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">HashSet添加元素底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet%E7%9A%84%E6%89%A9%E5%AE%B9%E5%92%8C%E8%BD%AC%E6%88%90%E7%BA%A2%E9%BB%91%E6%A0%91%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.2.</span> <span class="toc-text">HashSet的扩容和转成红黑树机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedHashSet"><span class="toc-number">1.4.</span> <span class="toc-text">LinkedHashSet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map%E6%8E%A5%E5%8F%A3%EF%BC%88JDK8%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">Map接口（JDK8的特点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.1.</span> <span class="toc-text">遍历方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap"><span class="toc-number">1.6.</span> <span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6"><span class="toc-number">1.6.1.</span> <span class="toc-text">HashMap底层机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hashtable%EF%BC%88%E4%B8%8D%E8%83%BD%E5%AD%98null%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">Hashtable（不能存null）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hashmap-%E5%92%8C-Hashtable%E5%AF%B9%E6%AF%94"><span class="toc-number">1.7.1.</span> <span class="toc-text">Hashmap 和 Hashtable对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Properties"><span class="toc-number">1.8.</span> <span class="toc-text">Properties</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">1.9.</span> <span class="toc-text">开发中如何使用集合实现类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%EF%BC%88generic%EF%BC%89"><span class="toc-number">1.10.</span> <span class="toc-text">泛型（generic）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.10.1.</span> <span class="toc-text">为什么是泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">1.10.2.</span> <span class="toc-text">泛型的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">1.10.3.</span> <span class="toc-text">泛型的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.10.4.</span> <span class="toc-text">自定义泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">1.10.4.1.</span> <span class="toc-text">自定义泛型类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.10.4.2.</span> <span class="toc-text">自定义泛型接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.10.4.3.</span> <span class="toc-text">自定义泛型方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%BB%A7%E6%89%BF%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">1.10.4.4.</span> <span class="toc-text">泛型的继承和通配符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JUnit"><span class="toc-number">1.10.5.</span> <span class="toc-text">JUnit</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%EF%BC%88Thread%EF%BC%89"><span class="toc-number">1.11.</span> <span class="toc-text">线程（Thread）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.11.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.11.2.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.11.3.</span> <span class="toc-text">线程的使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.11.3.1.</span> <span class="toc-text">创建线程的两种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="toc-number">1.11.3.1.1.</span> <span class="toc-text">继承Thread类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.11.3.1.2.</span> <span class="toc-text">实现Runnable接口</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Start-%E6%96%B9%E6%B3%95"><span class="toc-number">1.11.3.2.</span> <span class="toc-text">Start()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFThread-VS-%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.11.3.3.</span> <span class="toc-text">继承Thread VS 实现Runnable接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="toc-number">1.11.4.</span> <span class="toc-text">线程终止</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.11.5.</span> <span class="toc-text">线程的常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E7%AC%AC%E4%B8%80%E7%BB%84"><span class="toc-number">1.11.5.1.</span> <span class="toc-text">常用方法第一组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E7%AC%AC%E4%BA%8C%E7%BB%84"><span class="toc-number">1.11.5.2.</span> <span class="toc-text">常用方法第二组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%EF%BC%88Daemon%EF%BC%89"><span class="toc-number">1.11.6.</span> <span class="toc-text">用户线程和守护线程（Daemon）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.11.7.</span> <span class="toc-text">线程的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%88Synchronized%EF%BC%89"><span class="toc-number">1.11.8.</span> <span class="toc-text">线程同步（Synchronized）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%85%B7%E4%BD%93%E6%96%B9%E6%B3%95"><span class="toc-number">1.11.8.1.</span> <span class="toc-text">同步具体方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86"><span class="toc-number">1.11.9.</span> <span class="toc-text">同步原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">1.11.10.</span> <span class="toc-text">互斥锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="toc-number">1.11.10.1.</span> <span class="toc-text">注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-number">1.11.11.</span> <span class="toc-text">释放锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E4%BC%9A%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.11.11.1.</span> <span class="toc-text">不会释放锁的操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-number">1.12.</span> <span class="toc-text">IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6"><span class="toc-number">1.12.1.</span> <span class="toc-text">文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-number">1.12.2.</span> <span class="toc-text">文件的相关操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6"><span class="toc-number">1.12.2.1.</span> <span class="toc-text">创建文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84API"><span class="toc-number">1.12.2.2.</span> <span class="toc-text">常用的API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%9A%84%E6%93%8D%E4%BD%9C%E5%92%8C%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4"><span class="toc-number">1.12.2.3.</span> <span class="toc-text">目录的操作和文件删除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%B5%81%E5%8E%9F%E7%90%86"><span class="toc-number">1.12.3.</span> <span class="toc-text">IO流原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.13.</span> <span class="toc-text">流的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E6%B5%81"><span class="toc-number">1.13.1.</span> <span class="toc-text">节点流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%EF%BC%88InputStream-x2F-outputStream%EF%BC%89"><span class="toc-number">1.13.1.1.</span> <span class="toc-text">字节流（InputStream&#x2F;outputStream）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E5%AE%8C%E6%88%90%E6%97%A0%E6%8D%9F%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.13.1.1.1.</span> <span class="toc-text">字节输入输出流完成无损拷贝</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%88Reader-x2F-Writer%EF%BC%89"><span class="toc-number">1.13.1.2.</span> <span class="toc-text">字符流（Reader&#x2F;Writer）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.13.1.2.1.</span> <span class="toc-text">使用方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B5%81-x2F-%E5%8C%85%E8%A3%85%E6%B5%81"><span class="toc-number">1.13.2.</span> <span class="toc-text">处理流&#x2F;包装流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B5%81-BufferedReader-%E5%92%8C-BufferedWriter"><span class="toc-number">1.13.2.1.</span> <span class="toc-text">处理流-BufferedReader 和 BufferedWriter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BufferedOutputStream-%E5%92%8C-BufferedInputStream"><span class="toc-number">1.13.2.2.</span> <span class="toc-text">BufferedOutputStream 和 BufferedInputStream</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.13.3.</span> <span class="toc-text">序列化和反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B5%81-ObjectInputStream-%E5%92%8C-ObjectOutputStream%E3%80%81"><span class="toc-number">1.13.3.1.</span> <span class="toc-text">对象流-ObjectInputStream 和 ObjectOutputStream、</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">1.13.3.2.</span> <span class="toc-text">标准输入输出流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81-InputStreamReader-%E5%92%8C-OutputStreamWriter"><span class="toc-number">1.13.3.3.</span> <span class="toc-text">转换流-InputStreamReader 和 OutputStreamWriter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81-PrintStream-%E5%92%8C-PrintWrite"><span class="toc-number">1.13.3.4.</span> <span class="toc-text">打印流-PrintStream 和 PrintWrite</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Properties-%E7%B1%BB"><span class="toc-number">1.13.4.</span> <span class="toc-text">Properties 类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.13.4.1.</span> <span class="toc-text">常见方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="toc-number">2.</span> <span class="toc-text">网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-number">2.1.</span> <span class="toc-text">网络通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C-1"><span class="toc-number">2.2.</span> <span class="toc-text">网络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ip%E5%9C%B0%E5%9D%80"><span class="toc-number">2.3.</span> <span class="toc-text">ip地址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IPv4%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB"><span class="toc-number">2.3.1.</span> <span class="toc-text">IPv4地址分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D"><span class="toc-number">2.3.2.</span> <span class="toc-text">域名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-number">2.3.3.</span> <span class="toc-text">端口号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.4.</span> <span class="toc-text">网络通信协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%EF%BC%88TCP-x2F-IP%EF%BC%89"><span class="toc-number">2.4.1.</span> <span class="toc-text">协议（TCP&#x2F;IP）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%EF%BC%9A%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.4.2.</span> <span class="toc-text">TCP：传输控制协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%EF%BC%9A%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.4.3.</span> <span class="toc-text">UDP：用户数据协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InetAddress-%E7%B1%BB"><span class="toc-number">2.5.</span> <span class="toc-text">InetAddress 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-number">2.5.1.</span> <span class="toc-text">相关方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket"><span class="toc-number">2.6.</span> <span class="toc-text">Socket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%BC%96%E7%A8%8B"><span class="toc-number">2.7.</span> <span class="toc-text">TCP 网络通信编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.7.1.</span> <span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%9801"><span class="toc-number">2.7.1.1.</span> <span class="toc-text">面试题01</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%9802"><span class="toc-number">2.7.1.2.</span> <span class="toc-text">面试题02</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.7.1.3.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E5%B0%8F%E5%A7%BF%E5%8A%BF"><span class="toc-number">2.7.2.</span> <span class="toc-text">编程小姿势</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2-x2F-%E5%A4%9A%E9%A1%B9%E5%BC%8F%EF%BC%88%E9%9C%8D%E7%BA%B3%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">2.7.2.1.</span> <span class="toc-text">进制转换&#x2F;多项式（霍纳算法）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%B0%8F%E7%BB%86%E8%8A%82"><span class="toc-number">2.7.3.</span> <span class="toc-text">java小细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%AB%99"><span class="toc-number">2.7.4.</span> <span class="toc-text">网站</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/26/springboot/" title="springboot"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://service-5z0sdahv-1306777571.sh.apigw.tencentcs.com/release/" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="springboot"/></a><div class="content"><a class="title" href="/2023/03/26/springboot/" title="springboot">springboot</a><time datetime="2023-03-26T11:37:06.882Z" title="发表于 2023-03-26 19:37:06">2023-03-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/26/mybatis/" title="mybatis"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://service-5z0sdahv-1306777571.sh.apigw.tencentcs.com/release/" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mybatis"/></a><div class="content"><a class="title" href="/2023/03/26/mybatis/" title="mybatis">mybatis</a><time datetime="2023-03-26T11:36:16.438Z" title="发表于 2023-03-26 19:36:16">2023-03-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/26/git/" title="嵌入式学习"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://service-5z0sdahv-1306777571.sh.apigw.tencentcs.com/release/" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="嵌入式学习"/></a><div class="content"><a class="title" href="/2023/03/26/git/" title="嵌入式学习">嵌入式学习</a><time datetime="2023-03-26T11:34:42.657Z" title="发表于 2023-03-26 19:34:42">2023-03-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/26/mysql/" title="mysql"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://service-5z0sdahv-1306777571.sh.apigw.tencentcs.com/release/" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mysql"/></a><div class="content"><a class="title" href="/2023/03/26/mysql/" title="mysql">mysql</a><time datetime="2023-03-26T11:30:47.346Z" title="发表于 2023-03-26 19:30:47">2023-03-26</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2023 By Asahi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script async src="https://npm.elemecdn.com/tzy-blog/lib/js/other/sakura.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="70" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://asahif.github.io/categories/Linux/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 Linux (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://asahif.github.io/categories/web/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎮 web (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://asahif.github.io/categories/博客/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱‍👓 博客 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://asahif.github.io/categories/嵌入式/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 嵌入式 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://asahif.github.io/categories/java/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱‍👓 java (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://asahif.github.io/categories/数据库/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎮 数据库 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://asahif.github.io/categories/git/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 git (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="https://asahif.github.io/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f3f3f3;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/03/26/metajrs_web/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://service-5z0sdahv-1306777571.sh.apigw.tencentcs.com/release/" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-26</span><a class="blog-slider__title" href="2023/03/26/metajrs_web/" alt="">metajrs—web路线</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2023/03/26/metajrs_web/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/03/26/java/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://service-5z0sdahv-1306777571.sh.apigw.tencentcs.com/release/" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-26</span><a class="blog-slider__title" href="2023/03/26/java/" alt="">java基础</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2023/03/26/java/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/03/26/嵌入式/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://service-5z0sdahv-1306777571.sh.apigw.tencentcs.com/release/" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-26</span><a class="blog-slider__title" href="2023/03/26/嵌入式/" alt="">嵌入式学习</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2023/03/26/嵌入式/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/03/26/write/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://service-5z0sdahv-1306777571.sh.apigw.tencentcs.com/release/" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-26</span><a class="blog-slider__title" href="2023/03/26/write/" alt="">博客的书写</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2023/03/26/write/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/03/26/springboot/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://service-5z0sdahv-1306777571.sh.apigw.tencentcs.com/release/" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-26</span><a class="blog-slider__title" href="2023/03/26/springboot/" alt="">springboot</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2023/03/26/springboot/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/03/26/mysql/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://service-5z0sdahv-1306777571.sh.apigw.tencentcs.com/release/" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-26</span><a class="blog-slider__title" href="2023/03/26/mysql/" alt="">mysql</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2023/03/26/mysql/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/03/26/mybatis/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://service-5z0sdahv-1306777571.sh.apigw.tencentcs.com/release/" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-26</span><a class="blog-slider__title" href="2023/03/26/mybatis/" alt="">mybatis</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2023/03/26/mybatis/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/03/10/linux/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://service-5z0sdahv-1306777571.sh.apigw.tencentcs.com/release/" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-10</span><a class="blog-slider__title" href="2023/03/10/linux/" alt="">linux</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2023/03/10/linux/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/03/26/git/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://service-5z0sdahv-1306777571.sh.apigw.tencentcs.com/release/" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-26</span><a class="blog-slider__title" href="2023/03/26/git/" alt="">嵌入式学习</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2023/03/26/git/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --></body></html>